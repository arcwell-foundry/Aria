"""
Emotional Intelligence Engine for ARIA.

Enables authentic, non-sycophantic emotional support by detecting
emotional context and generating appropriate acknowledgments.
"""

from __future__ import annotations

import logging
from dataclasses import dataclass, field
from datetime import UTC, datetime
from enum import Enum
from typing import Any

from pydantic import BaseModel, Field

from src.core.task_types import TaskType

logger = logging.getLogger(__name__)


class EmotionalContext(str, Enum):
    """Classification of emotional context in user messages."""

    CELEBRATION = "celebration"
    SETBACK = "setback"
    FRUSTRATION = "frustration"
    ANXIETY = "anxiety"
    NEUTRAL = "neutral"
    EXCITEMENT = "excitement"
    DISAPPOINTMENT = "disappointment"


class SupportType(str, Enum):
    """Type of emotional support to provide."""

    CELEBRATE = "celebrate"
    EMPATHIZE = "empathize"
    REDIRECT = "redirect"
    REASSURE = "reassure"
    ACKNOWLEDGE = "acknowledge"
    SPACE = "space"


# Context-specific avoidance lists - things NOT to say
CONTEXT_AVOIDANCES: dict[EmotionalContext, list[str]] = {
    EmotionalContext.CELEBRATION: [
        "generic 'great job' or 'good work'",
        "immediately pivoting to next task or goal",
        "downplaying the achievement",
        "comparing to others' achievements",
        "adding qualifiers ('but you still need to...')",
    ],
    EmotionalContext.SETBACK: [
        "toxic positivity ('everything happens for a reason')",
        "assigning blame or fault",
        "immediate problem-solving without acknowledgment",
        "minimizing ('it's not that big a deal')",
        "unsolicited advice without empathy first",
    ],
    EmotionalContext.FRUSTRATION: [
        "minimizing ('it's not that bad')",
        "'calm down' or 'relax'",
        "dismissing the frustration",
        "telling them they're overreacting",
        "offering solutions before validating feelings",
    ],
    EmotionalContext.ANXIETY: [
        "dismissing concerns ('don't worry about it')",
        "false reassurances ('everything will be fine')",
        "telling them to just 'stop worrying'",
        "minimizing the source of anxiety",
        "comparing to worse situations",
    ],
    EmotionalContext.DISAPPOINTMENT: [
        "silver linings too quickly",
        "minimizing ('it's not the end of the world')",
        "unsolicited advice immediately",
        "telling them to 'look on the bright side'",
        "dismissing the disappointment",
    ],
    EmotionalContext.EXCITEMENT: [
        "dampening enthusiasm ('let's not get ahead of ourselves')",
        "immediate practical concerns",
        "comparing to bigger achievements",
        "generic responses without matching energy",
    ],
    EmotionalContext.NEUTRAL: [
        "forcing emotional engagement where none exists",
        "over-interpreting neutral statements",
        "inappropriate emotional responses",
    ],
}

# Context to support type mapping
CONTEXT_SUPPORT_MAP: dict[EmotionalContext, SupportType] = {
    EmotionalContext.CELEBRATION: SupportType.CELEBRATE,
    EmotionalContext.SETBACK: SupportType.EMPATHIZE,
    EmotionalContext.FRUSTRATION: SupportType.ACKNOWLEDGE,
    EmotionalContext.ANXIETY: SupportType.REASSURE,
    EmotionalContext.DISAPPOINTMENT: SupportType.EMPATHIZE,
    EmotionalContext.EXCITEMENT: SupportType.CELEBRATE,
    EmotionalContext.NEUTRAL: SupportType.ACKNOWLEDGE,
}


@dataclass
class EmotionalResponse:
    """Structured emotional response generated by the engine."""

    context: EmotionalContext
    acknowledgment: str
    support_type: SupportType
    response_elements: list[str] = field(default_factory=list)
    avoid_list: list[str] = field(default_factory=list)
    created_at: datetime = field(default_factory=lambda: datetime.now(UTC))

    def to_dict(self) -> dict[str, Any]:
        """Serialize to dictionary for storage/transmission."""
        return {
            "context": self.context.value,
            "acknowledgment": self.acknowledgment,
            "support_type": self.support_type.value,
            "response_elements": self.response_elements,
            "avoid_list": self.avoid_list,
            "created_at": self.created_at.isoformat(),
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> EmotionalResponse:
        """Deserialize from dictionary."""
        return cls(
            context=EmotionalContext(data["context"]),
            acknowledgment=data["acknowledgment"],
            support_type=SupportType(data["support_type"]),
            response_elements=data.get("response_elements", []),
            avoid_list=data.get("avoid_list", []),
            created_at=datetime.fromisoformat(data["created_at"])
            if "created_at" in data
            else datetime.now(UTC),
        )


# Pydantic models for API
class EmotionalResponseRequest(BaseModel):
    """Request model for emotional response endpoint."""

    message: str = Field(..., min_length=1, description="User message to analyze")
    conversation_history: list[dict[str, Any]] | None = Field(
        None, description="Recent messages for context"
    )


class EmotionalResponseResponse(BaseModel):
    """Response model for emotional response endpoint."""

    context: str = Field(..., description="Detected emotional context")
    acknowledgment: str = Field(..., description="Generated acknowledgment")
    support_type: str = Field(..., description="Type of support recommended")
    response_elements: list[str] = Field(..., description="Elements to include in response")
    avoid_list: list[str] = Field(..., description="Things to avoid saying")


class EmotionalIntelligenceEngine:
    """
    Engine for detecting emotional context and generating appropriate responses.

    Provides authentic, non-sycophantic emotional support by:
    - Classifying the emotional context of user messages
    - Generating contextual acknowledgments that reference shared history
    - Providing guidance on what NOT to say to avoid harmful patterns
    """

    def __init__(
        self,
        db_client: Any = None,
        llm_client: Any = None,
        theory_of_mind: Any = None,
        memory_service: Any = None,
    ) -> None:
        """
        Initialize the emotional intelligence engine.

        Args:
            db_client: Supabase client for persistence (optional)
            llm_client: LLM client for context detection (optional)
            theory_of_mind: Theory of Mind module for user state (optional)
            memory_service: Memory service for shared history (optional)
        """
        # Lazy imports to avoid circular dependencies
        if db_client is None:
            from src.db.supabase import SupabaseClient

            self._db = SupabaseClient.get_client()
        else:
            self._db = db_client

        if llm_client is None:
            from src.core.llm import LLMClient

            self._llm = LLMClient()
        else:
            self._llm = llm_client

        self._theory_of_mind = theory_of_mind
        self._memory = memory_service

    async def detect_context(
        self,
        message: str,
        conversation_history: list[dict[str, Any]] | None = None,
    ) -> EmotionalContext:
        """
        Detect the emotional context of a user message using LLM.

        Args:
            message: The user's message to analyze
            conversation_history: Recent conversation for additional context

        Returns:
            Classified EmotionalContext
        """
        history_context = ""
        if conversation_history:
            # Include last 5 messages for context
            recent = conversation_history[-5:]
            history_context = "\n".join(
                f"{'User' if m.get('role') == 'user' else 'ARIA'}: {m.get('content', '')}"
                for m in recent
            )

        prompt_parts = [
            "Analyze the emotional context of this user message. Classify into exactly one category.",
            "",
            "Categories:",
            "- celebration: User is sharing a win, success, or positive achievement",
            "- setback: User experienced a failure, rejection, or obstacle",
            "- frustration: User is annoyed, irritated, or struggling with something",
            "- anxiety: User is worried, nervous, or concerned about something",
            "- excitement: User is enthusiastic or eager about something",
            "- disappointment: User is let down by an outcome",
            "- neutral: No strong emotional content",
        ]

        if history_context:
            prompt_parts.append("")
            prompt_parts.append("Recent conversation context:")
            prompt_parts.append(history_context)

        prompt_parts.append(f'\nUser message: "{message}"')
        prompt_parts.append("\nRespond with ONLY the category name, nothing else.")

        prompt = "\n".join(prompt_parts)

        try:
            response = await self._llm.generate_response(
                messages=[{"role": "user", "content": prompt}],
                temperature=0.3,
                max_tokens=20,
                task=TaskType.GENERAL,
                agent_id="emotional",
            )
            context_str = response.strip().lower()

            # Map to enum, default to neutral if not recognized
            for ctx in EmotionalContext:
                if ctx.value in context_str:
                    return ctx

            logger.warning(f"Unrecognized emotional context: {context_str}, defaulting to neutral")
            return EmotionalContext.NEUTRAL

        except Exception as e:
            logger.error(f"Error detecting emotional context: {e}")
            return EmotionalContext.NEUTRAL

    async def generate_emotional_response(
        self,
        user_id: str,
        message: str,
        context: EmotionalContext | None = None,
        conversation_history: list[dict[str, Any]] | None = None,
    ) -> EmotionalResponse:
        """
        Generate an emotional response for the given message and context.

        Args:
            user_id: ID of the user
            message: The user's message
            context: Pre-detected context (optional, will detect if not provided)
            conversation_history: Recent conversation for context

        Returns:
            Generated EmotionalResponse with acknowledgment and guidance
        """
        # Detect context if not provided
        if context is None:
            context = await self.detect_context(message, conversation_history)

        # Determine support type and avoidances
        support_type = self._determine_support_type(context)
        avoid_list = self._get_avoidances(context)

        # Generate acknowledgment with shared history
        acknowledgment = await self._generate_acknowledgment(
            user_id=user_id,
            context=context,
            message=message,
            conversation_history=conversation_history,
        )

        # Generate response elements based on context
        response_elements = self._generate_response_elements(context, message)

        return EmotionalResponse(
            context=context,
            acknowledgment=acknowledgment,
            support_type=support_type,
            response_elements=response_elements,
            avoid_list=avoid_list,
        )

    async def record_response(
        self,
        user_id: str,
        context: EmotionalContext,
        message: str,
        response: EmotionalResponse,
        user_reaction: str | None = None,
    ) -> bool:
        """
        Record an emotional response for learning and analytics.

        Args:
            user_id: ID of the user
            context: The emotional context
            message: The original user message
            response: The generated response
            user_reaction: Optional user reaction/feedback

        Returns:
            True if recorded successfully
        """
        try:
            data = {
                "user_id": user_id,
                "context": context.value,
                "message": message,
                "response": response.to_dict(),
                "user_reaction": user_reaction,
            }

            result = self._db.table("companion_emotional_responses").insert(data).execute()

            return bool(result.data)

        except Exception as e:
            logger.error(f"Error recording emotional response: {e}")
            return False

    def _determine_support_type(self, context: EmotionalContext) -> SupportType:
        """Map emotional context to appropriate support type."""
        return CONTEXT_SUPPORT_MAP.get(context, SupportType.ACKNOWLEDGE)

    def _get_avoidances(self, context: EmotionalContext) -> list[str]:
        """Get the list of things to avoid for this context."""
        return CONTEXT_AVOIDANCES.get(context, [])

    async def _generate_acknowledgment(
        self,
        user_id: str,
        context: EmotionalContext,
        message: str,
        conversation_history: list[dict[str, Any]] | None = None,
    ) -> str:
        """
        Generate a contextually appropriate acknowledgment.

        References shared history when available for personalized responses.
        """
        # Build shared history context if memory service is available
        shared_context = ""
        if self._memory:
            try:
                # Try to get relevant episodic memories
                # This is a simplified version - actual implementation
                # would query semantic/episodic memory
                shared_context = await self._get_shared_history_context(user_id, message)
            except Exception as e:
                logger.warning(f"Could not retrieve shared history: {e}")

        # Also use conversation history
        if conversation_history:
            recent_context = "\n".join(
                f"{m.get('role', 'user')}: {m.get('content', '')}"
                for m in conversation_history[-3:]
            )
            if shared_context:
                shared_context = f"{shared_context}\n\nRecent conversation:\n{recent_context}"
            else:
                shared_context = f"Recent conversation:\n{recent_context}"

        # Generate acknowledgment based on context type
        context_prompts = {
            EmotionalContext.CELEBRATION: "Generate a genuine acknowledgment that celebrates this achievement. Be specific about what makes this meaningful. Reference any shared context if relevant. Avoid generic praise.",
            EmotionalContext.SETBACK: "Generate an empathetic acknowledgment that validates the difficulty of this setback. Do NOT offer solutions or toxic positivity. Simply acknowledge the impact.",
            EmotionalContext.FRUSTRATION: "Generate an acknowledgment that validates their frustration without minimizing it. Show you understand why this is frustrating. Do NOT tell them to calm down.",
            EmotionalContext.ANXIETY: "Generate a supportive acknowledgment that takes their concerns seriously. Do NOT dismiss or minimize. Acknowledge the uncertainty they're facing.",
            EmotionalContext.DISAPPOINTMENT: "Generate an acknowledgment that validates the disappointment. Do NOT immediately look for silver linings. Let them feel the disappointment.",
            EmotionalContext.EXCITEMENT: "Generate an acknowledgment that matches their enthusiasm. Be genuinely excited with them. Reference specifics from what they shared.",
            EmotionalContext.NEUTRAL: "Generate a brief, professional acknowledgment that shows you heard them without forcing emotional engagement.",
        }

        prompt_parts = [context_prompts.get(context, context_prompts[EmotionalContext.NEUTRAL])]

        if shared_context:
            prompt_parts.append("")
            prompt_parts.append("Shared context with this user:")
            prompt_parts.append(shared_context)

        prompt_parts.append(f'\nTheir message: "{message}"')
        prompt_parts.append(
            "\nGenerate a single, direct acknowledgment (1-2 sentences). Do not include quotes or meta-commentary."
        )

        prompt = "\n".join(prompt_parts)

        try:
            response = await self._llm.generate_response(
                messages=[{"role": "user", "content": prompt}],
                temperature=0.5,
                max_tokens=150,
                task=TaskType.GENERAL,
                agent_id="emotional",
            )
            return response.strip().strip('"')

        except Exception as e:
            logger.error(f"Error generating acknowledgment: {e}")
            # Fallback acknowledgments
            fallbacks = {
                EmotionalContext.CELEBRATION: "That's a meaningful win.",
                EmotionalContext.SETBACK: "I understand this is difficult.",
                EmotionalContext.FRUSTRATION: "I hear you - that sounds genuinely frustrating.",
                EmotionalContext.ANXIETY: "Your concerns make sense given the uncertainty.",
                EmotionalContext.DISAPPOINTMENT: "I can see why that's disappointing.",
                EmotionalContext.EXCITEMENT: "That sounds exciting!",
                EmotionalContext.NEUTRAL: "I understand.",
            }
            return fallbacks.get(context, "I understand.")

    async def _get_shared_history_context(self, _user_id: str, _message: str) -> str:
        """
        Retrieve relevant shared history for personalization.

        Queries memory service for relevant episodic memories.
        """
        if not self._memory:
            return ""

        try:
            # This would normally query the memory service
            # For now, return empty string - actual implementation
            # would use semantic search on episodic memories
            return ""
        except Exception as e:
            logger.warning(f"Error getting shared history: {e}")
            return ""

    def _generate_response_elements(self, context: EmotionalContext, _message: str) -> list[str]:
        """
        Generate response elements to include based on context.

        These are suggestions for how to structure the full response.
        """
        elements = []

        if context == EmotionalContext.CELEBRATION:
            elements = [
                "Acknowledge the specific achievement",
                "Connect to their goals or values if known",
                "Match their energy level",
            ]
        elif context == EmotionalContext.SETBACK:
            elements = [
                "Validate the emotional impact",
                "Acknowledge effort already invested",
                "Wait for cue before discussing next steps",
            ]
        elif context == EmotionalContext.FRUSTRATION:
            elements = [
                "Name the frustration explicitly",
                "Acknowledge what's blocking them",
                "Don't rush to solutions",
            ]
        elif context == EmotionalContext.ANXIETY:
            elements = [
                "Take concerns seriously",
                "Acknowledge uncertainty is hard",
                "Offer presence, not false promises",
            ]
        elif context == EmotionalContext.DISAPPOINTMENT:
            elements = [
                "Let them express the disappointment",
                "Don't minimize or redirect quickly",
                "Be present with them in it",
            ]
        elif context == EmotionalContext.EXCITEMENT:
            elements = [
                "Match their enthusiasm genuinely",
                "Ask about specific details",
                "Celebrate with them",
            ]
        elif context == EmotionalContext.NEUTRAL:
            elements = [
                "Respond appropriately to the content",
                "Stay professional and direct",
            ]

        return elements
