# US-928, US-930, US-933 Completion Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Complete the remaining gaps in three Sprint 9.3 stories: billing tests (US-928), error handling gaps (US-930), and help system integration (US-933).

**Architecture:** These are gap-filling tasks on existing implementations. US-928 needs additional test classes for edge cases. US-930 needs ErrorToaster tests. US-933 needs HelpTooltip deployed across pages and FeedbackWidget integrated into chat messages.

**Tech Stack:** Python/pytest (backend tests), React/TypeScript/Vitest (frontend tests + components), Tailwind CSS

---

## Task 1: US-928 — Add BillingService edge case tests

**Files:**
- Modify: `backend/tests/test_billing_service.py`

**Context:** The test file already has 4 test classes (TestBillingService, TestInvoiceFormatting, TestSubscriptionStatusParsing, TestBillingEmailNotifications) with ~645 lines. We need to add edge case coverage that's missing.

**Step 1: Add edge case tests to the existing test file**

Append these new test classes after the existing `TestBillingEmailNotifications` class:

```python
class TestBillingServiceNotConfigured:
    """Test BillingService behavior when Stripe is not configured."""

    @pytest.mark.asyncio
    async def test_get_or_create_customer_raises_when_not_configured(
        self, billing_service
    ):
        """Test that creating a customer raises BillingError when Stripe is not configured."""
        billing_service._stripe_key = ""
        with pytest.raises(BillingError, match="Stripe is not configured"):
            await billing_service.get_or_create_customer("company-123", "admin@example.com")

    @pytest.mark.asyncio
    async def test_create_checkout_session_raises_when_not_configured(
        self, billing_service
    ):
        """Test that creating a checkout session raises when Stripe is not configured."""
        billing_service._stripe_key = ""
        with pytest.raises(BillingError, match="Stripe is not configured"):
            await billing_service.create_checkout_session("company-123", "admin@example.com")

    @pytest.mark.asyncio
    async def test_create_portal_session_raises_when_not_configured(
        self, billing_service
    ):
        """Test that creating a portal session raises when Stripe is not configured."""
        billing_service._stripe_key = ""
        with pytest.raises(BillingError, match="Stripe is not configured"):
            await billing_service.create_portal_session("company-123")

    @pytest.mark.asyncio
    async def test_get_invoices_returns_empty_when_not_configured(
        self, billing_service
    ):
        """Test that get_invoices returns empty list when Stripe is not configured."""
        billing_service._stripe_key = ""
        result = await billing_service.get_invoices("company-123")
        assert result == []

    @pytest.mark.asyncio
    async def test_handle_webhook_raises_when_not_configured(
        self, billing_service
    ):
        """Test that handling webhooks raises when Stripe is not configured."""
        billing_service._stripe_key = ""
        with pytest.raises(BillingError, match="Stripe is not configured"):
            await billing_service.handle_webhook(b"payload", "sig_header")


class TestWebhookEdgeCases:
    """Test webhook handling edge cases."""

    @pytest.mark.asyncio
    async def test_webhook_secret_not_configured(
        self, billing_service, mock_stripe
    ):
        """Test that webhook raises when webhook secret is not configured."""
        with patch("src.services.billing_service.settings") as mock_settings:
            mock_settings.STRIPE_WEBHOOK_SECRET.get_secret_value.return_value = ""
            with pytest.raises(BillingError, match="Webhook secret not configured"):
                await billing_service.handle_webhook(b"payload", "sig_header")

    @pytest.mark.asyncio
    async def test_unhandled_webhook_event_type(
        self, billing_service, mock_stripe
    ):
        """Test that unhandled event types are logged but don't raise."""
        payload = b"test_payload"
        sig_header = "t=123,v1=abc123"

        with patch("src.services.billing_service.settings") as mock_settings:
            mock_settings.STRIPE_WEBHOOK_SECRET.get_secret_value.return_value = "whsec_test"

            mock_event = MagicMock()
            mock_event.type = "customer.updated"
            mock_event.data.object = MagicMock()

            mock_stripe.Webhook.construct_event.return_value = mock_event

            # Should not raise
            await billing_service.handle_webhook(payload, sig_header)

    @pytest.mark.asyncio
    async def test_checkout_completed_without_subscription(
        self, billing_service, mock_stripe
    ):
        """Test checkout completed event when session has no subscription."""
        billing_service._update_subscription_status = AsyncMock()

        mock_session = MagicMock()
        mock_session.customer = "cus_123"
        mock_session.subscription = None  # No subscription (setup mode)

        await billing_service._handle_checkout_completed(mock_session)

        # Should not update subscription status
        billing_service._update_subscription_status.assert_not_called()


class TestUpdateSubscriptionStatus:
    """Test internal subscription status update logic."""

    @pytest.mark.asyncio
    async def test_update_status_no_company_found(
        self, billing_service, mock_supabase
    ):
        """Test status update when no company found for customer ID."""
        mock_client = MagicMock()
        mock_supabase.get_client.return_value = mock_client
        mock_client.table.return_value.select.return_value.eq.return_value.single.return_value.execute.return_value = MagicMock(
            data=None
        )

        mock_source = MagicMock()
        mock_source.customer = "cus_unknown"

        # Should not raise, just log warning
        await billing_service._update_subscription_status(
            "cus_unknown", "active", mock_source
        )

        # Should not attempt to update
        mock_client.table.return_value.update.assert_not_called()

    @pytest.mark.asyncio
    async def test_update_status_builds_metadata_from_subscription(
        self, billing_service, mock_supabase
    ):
        """Test that metadata is correctly extracted from subscription source."""
        mock_client = MagicMock()
        mock_supabase.get_client.return_value = mock_client

        mock_client.table.return_value.select.return_value.eq.return_value.single.return_value.execute.return_value = MagicMock(
            data={"id": "company-123"}
        )

        # Mock update chain
        mock_client.table.return_value.update.return_value.eq.return_value.execute.return_value = MagicMock()

        mock_source = MagicMock()
        mock_source.current_period_end = 1735689600
        mock_source.cancel_at_period_end = True
        mock_price = MagicMock()
        mock_price.nickname = "ARIA Annual"
        mock_item = MagicMock()
        mock_item.price = mock_price
        mock_source.items = MagicMock()
        mock_source.items.data = [mock_item]

        await billing_service._update_subscription_status(
            "cus_123", "active", mock_source
        )

        # Verify update was called
        mock_client.table.return_value.update.assert_called_once()
        call_args = mock_client.table.return_value.update.call_args[0][0]
        assert call_args["subscription_status"] == "active"
        assert call_args["subscription_metadata"]["cancel_at_period_end"] is True
        assert call_args["subscription_metadata"]["plan"] == "ARIA Annual"

    @pytest.mark.asyncio
    async def test_update_status_handles_database_error(
        self, billing_service, mock_supabase, caplog
    ):
        """Test that database errors are caught and logged."""
        mock_client = MagicMock()
        mock_supabase.get_client.return_value = mock_client
        mock_client.table.side_effect = Exception("Database connection failed")

        mock_source = MagicMock()

        # Should not raise
        await billing_service._update_subscription_status(
            "cus_123", "active", mock_source
        )


class TestGetCompanyAdminEmail:
    """Test admin email lookup for billing notifications."""

    @pytest.mark.asyncio
    async def test_returns_none_when_no_company(
        self, billing_service, mock_supabase
    ):
        """Test that None is returned when company not found."""
        mock_client = MagicMock()
        mock_supabase.get_client.return_value = mock_client
        mock_client.table.return_value.select.return_value.eq.return_value.single.return_value.execute.return_value = MagicMock(
            data=None
        )

        result = await billing_service._get_company_admin_email("cus_unknown")
        assert result is None

    @pytest.mark.asyncio
    async def test_returns_none_when_no_admin_users(
        self, billing_service, mock_supabase
    ):
        """Test that None is returned when company has no admin users."""
        mock_client = MagicMock()
        mock_supabase.get_client.return_value = mock_client

        mock_companies_table = MagicMock()
        mock_companies_table.select.return_value.eq.return_value.single.return_value.execute.return_value = MagicMock(
            data={"id": "company-123"}
        )

        mock_user_profiles_table = MagicMock()
        mock_user_profiles_table.select.return_value.eq.return_value.eq.return_value.eq.return_value.limit.return_value.execute.return_value = MagicMock(
            data=[]
        )

        def table_side_effect(table_name):
            if table_name == "companies":
                return mock_companies_table
            elif table_name == "user_profiles":
                return mock_user_profiles_table
            return MagicMock()

        mock_client.table.side_effect = table_side_effect

        result = await billing_service._get_company_admin_email("cus_123")
        assert result is None

    @pytest.mark.asyncio
    async def test_returns_none_on_exception(
        self, billing_service, mock_supabase
    ):
        """Test that None is returned on database exceptions."""
        mock_client = MagicMock()
        mock_supabase.get_client.return_value = mock_client
        mock_client.table.side_effect = Exception("Database error")

        result = await billing_service._get_company_admin_email("cus_123")
        assert result is None


class TestCheckoutSessionCreation:
    """Test checkout session creation edge cases."""

    @pytest.mark.asyncio
    async def test_creates_setup_mode_without_price_id(
        self, billing_service, mock_stripe
    ):
        """Test that checkout creates setup mode when STRIPE_PRICE_ID is not set."""
        billing_service.get_or_create_customer = AsyncMock(return_value="cus_123")

        mock_session = MagicMock()
        mock_session.url = "https://checkout.stripe.com/session"
        mock_session.id = "cs_test_123"
        mock_stripe.checkout.Session.create.return_value = mock_session

        with patch("src.services.billing_service.settings") as mock_settings:
            mock_settings.STRIPE_PRICE_ID = ""
            mock_settings.APP_URL = "http://localhost:3000"

            result = await billing_service.create_checkout_session(
                "company-123", "admin@example.com"
            )

            assert result == "https://checkout.stripe.com/session"
            call_args = mock_stripe.checkout.Session.create.call_args
            assert call_args.kwargs.get("mode") == "setup" or call_args[1].get("mode") == "setup"

    @pytest.mark.asyncio
    async def test_uses_custom_urls_when_provided(
        self, billing_service, mock_stripe
    ):
        """Test that custom success and cancel URLs are used when provided."""
        billing_service.get_or_create_customer = AsyncMock(return_value="cus_123")

        mock_session = MagicMock()
        mock_session.url = "https://checkout.stripe.com/session"
        mock_session.id = "cs_test_123"
        mock_stripe.checkout.Session.create.return_value = mock_session

        with patch("src.services.billing_service.settings") as mock_settings:
            mock_settings.STRIPE_PRICE_ID = "price_123"
            mock_settings.APP_URL = "http://localhost:3000"

            await billing_service.create_checkout_session(
                "company-123",
                "admin@example.com",
                success_url="https://custom.com/success",
                cancel_url="https://custom.com/cancel",
            )

            call_args = mock_stripe.checkout.Session.create.call_args
            assert "https://custom.com/success" in str(call_args)
            assert "https://custom.com/cancel" in str(call_args)

    @pytest.mark.asyncio
    async def test_portal_session_no_stripe_customer(
        self, billing_service, mock_supabase
    ):
        """Test portal session creation when company has no Stripe customer."""
        mock_client = MagicMock()
        mock_supabase.get_client.return_value = mock_client
        mock_client.table.return_value.select.return_value.eq.return_value.single.return_value.execute.return_value = MagicMock(
            data={"id": "company-123", "stripe_customer_id": None}
        )

        with pytest.raises(BillingError, match="No Stripe customer"):
            await billing_service.create_portal_session("company-123")


class TestInvoiceEdgeCases:
    """Test invoice retrieval edge cases."""

    @pytest.mark.asyncio
    async def test_invoice_with_null_fields(
        self, billing_service, mock_supabase, mock_stripe
    ):
        """Test handling invoices with null total, created, or pdf fields."""
        mock_client = MagicMock()
        mock_supabase.get_client.return_value = mock_client
        mock_client.table.return_value.select.return_value.eq.return_value.single.return_value.execute.return_value = MagicMock(
            data={"id": "company-123", "stripe_customer_id": "cus_123"}
        )

        mock_invoice = MagicMock()
        mock_invoice.id = "in_null"
        mock_invoice.total = None
        mock_invoice.currency = "usd"
        mock_invoice.status = "draft"
        mock_invoice.created = None
        mock_invoice.invoice_pdf = None

        mock_stripe.Invoice.list.return_value = MagicMock(data=[mock_invoice])

        result = await billing_service.get_invoices("company-123")

        assert len(result) == 1
        assert result[0]["amount"] == 0  # None total → 0
        assert result[0]["date"] is None  # None created → None
        assert result[0]["pdf_url"] is None

    @pytest.mark.asyncio
    async def test_invoice_zero_amount(
        self, billing_service, mock_supabase, mock_stripe
    ):
        """Test handling zero-amount invoices."""
        mock_client = MagicMock()
        mock_supabase.get_client.return_value = mock_client
        mock_client.table.return_value.select.return_value.eq.return_value.single.return_value.execute.return_value = MagicMock(
            data={"id": "company-123", "stripe_customer_id": "cus_123"}
        )

        mock_invoice = MagicMock()
        mock_invoice.id = "in_zero"
        mock_invoice.total = 0
        mock_invoice.currency = "usd"
        mock_invoice.status = "paid"
        mock_invoice.created = 1704067200
        mock_invoice.invoice_pdf = "https://example.com/invoice.pdf"

        mock_stripe.Invoice.list.return_value = MagicMock(data=[mock_invoice])

        result = await billing_service.get_invoices("company-123")

        assert result[0]["amount"] == 0.0


class TestSubscriptionStatusEdgeCases:
    """Test subscription status parsing edge cases."""

    @pytest.mark.asyncio
    async def test_status_with_no_stripe_customer(
        self, billing_service, mock_supabase
    ):
        """Test status falls back to database when no Stripe customer."""
        mock_client = MagicMock()
        mock_supabase.get_client.return_value = mock_client

        mock_client.table.return_value.select.return_value.eq.return_value.single.return_value.execute.return_value = MagicMock(
            data={
                "id": "company-123",
                "stripe_customer_id": None,
                "subscription_status": "trial",
                "subscription_metadata": {},
            }
        )

        mock_seats = MagicMock()
        mock_seats.count = 1
        mock_client.table.return_value.select.return_value.eq.return_value.execute.return_value = mock_seats

        result = await billing_service.get_subscription_status("company-123")

        assert result["status"] == "trial"
        assert result["seats_used"] == 1

    @pytest.mark.asyncio
    async def test_status_stripe_api_failure_falls_back(
        self, billing_service, mock_supabase, mock_stripe
    ):
        """Test that Stripe API failure falls back to database data."""
        mock_client = MagicMock()
        mock_supabase.get_client.return_value = mock_client

        mock_client.table.return_value.select.return_value.eq.return_value.single.return_value.execute.return_value = MagicMock(
            data={
                "id": "company-123",
                "stripe_customer_id": "cus_123",
                "subscription_status": "active",
                "subscription_metadata": {"plan": "ARIA Annual"},
            }
        )

        mock_seats = MagicMock()
        mock_seats.count = 2
        mock_client.table.return_value.select.return_value.eq.return_value.execute.return_value = mock_seats

        # Stripe API fails
        mock_stripe.Subscription.list.side_effect = Exception("Stripe API error")

        result = await billing_service.get_subscription_status("company-123")

        # Should fall back to database values
        assert result["status"] == "active"
        assert result["plan"] == "ARIA Annual"

    @pytest.mark.asyncio
    async def test_status_subscription_no_price_nickname(
        self, billing_service, mock_supabase, mock_stripe
    ):
        """Test status parsing when subscription price has no nickname."""
        mock_client = MagicMock()
        mock_supabase.get_client.return_value = mock_client

        mock_client.table.return_value.select.return_value.eq.return_value.single.return_value.execute.return_value = MagicMock(
            data={
                "id": "company-123",
                "stripe_customer_id": "cus_123",
                "subscription_status": "trial",
                "subscription_metadata": {},
            }
        )

        mock_seats = MagicMock()
        mock_seats.count = 1
        mock_client.table.return_value.select.return_value.eq.return_value.execute.return_value = mock_seats

        mock_subscription = MagicMock()
        mock_subscription.status = "active"
        mock_subscription.current_period_end = 1735689600
        mock_subscription.cancel_at_period_end = False

        mock_price = MagicMock()
        mock_price.nickname = None
        mock_price.id = "price_abc123"

        mock_item = MagicMock()
        mock_item.price = mock_price
        mock_subscription.items = MagicMock()
        mock_subscription.items.data = [mock_item]

        mock_stripe.Subscription.list.return_value = MagicMock(data=[mock_subscription])

        result = await billing_service.get_subscription_status("company-123")

        # Should fall back to price ID when nickname is None
        assert result["plan"] == "price_abc123"

    @pytest.mark.asyncio
    async def test_status_seats_count_none(
        self, billing_service, mock_supabase
    ):
        """Test status when seats count returns None."""
        mock_client = MagicMock()
        mock_supabase.get_client.return_value = mock_client

        mock_client.table.return_value.select.return_value.eq.return_value.single.return_value.execute.return_value = MagicMock(
            data={
                "id": "company-123",
                "stripe_customer_id": None,
                "subscription_status": "trial",
                "subscription_metadata": {},
            }
        )

        mock_seats = MagicMock()
        mock_seats.count = None
        mock_client.table.return_value.select.return_value.eq.return_value.execute.return_value = mock_seats

        result = await billing_service.get_subscription_status("company-123")

        assert result["seats_used"] == 0
```

**Step 2: Run the tests**

Run: `cd /Users/dhruv/aria && python -m pytest backend/tests/test_billing_service.py -v`
Expected: All tests PASS (existing + new)

**Step 3: Commit**

```bash
git add backend/tests/test_billing_service.py
git commit -m "test: US-928 add billing service edge case tests"
```

---

## Task 2: US-930 — Add ErrorToaster component tests

**Files:**
- Create: `frontend/src/components/__tests__/ErrorToaster.test.tsx`

**Context:** ErrorToaster.tsx uses framer-motion for animations, subscribes to error events via `onError()`, and renders toast notifications. The error event system (`lib/errorEvents.ts`) already has tests. We need component-level tests.

**Step 1: Create the ErrorToaster test file**

```tsx
import { render, screen, fireEvent, waitFor, act } from '@testing-library/react';
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { ErrorToaster } from '../ErrorToaster';
import * as errorEvents from '@/lib/errorEvents';
import type { ErrorEvent } from '@/lib/errorEvents';

// Mock framer-motion to avoid animation issues in tests
vi.mock('framer-motion', () => ({
  motion: {
    div: ({ children, className, style, ...props }: React.PropsWithChildren<Record<string, unknown>>) => (
      <div className={className as string} style={style as React.CSSProperties} {...props}>{children}</div>
    ),
  },
  AnimatePresence: ({ children }: React.PropsWithChildren) => <>{children}</>,
}));

function createMockError(overrides: Partial<ErrorEvent> = {}): ErrorEvent {
  return {
    id: `error-${Date.now()}-${Math.random()}`,
    type: 'server',
    title: 'Server Error',
    description: 'Something went wrong on our end',
    ...overrides,
  };
}

describe('ErrorToaster', () => {
  let errorCallback: ((error: ErrorEvent) => void) | null = null;

  beforeEach(() => {
    vi.useFakeTimers();
    errorCallback = null;

    // Capture the callback registered with onError
    vi.spyOn(errorEvents, 'onError').mockImplementation((callback) => {
      errorCallback = callback;
      return () => {
        errorCallback = null;
      };
    });

    vi.spyOn(errorEvents, 'getColorForErrorType').mockReturnValue({
      bg: 'bg-red-900/20',
      border: 'border-red-500/30',
      icon: 'text-red-400',
    });

    vi.spyOn(errorEvents, 'getDismissDelay').mockReturnValue(5000);
  });

  afterEach(() => {
    vi.useRealTimers();
    vi.restoreAllMocks();
  });

  describe('rendering', () => {
    it('renders empty when no errors', () => {
      const { container } = render(<ErrorToaster />);
      const toastContainer = container.firstChild as HTMLElement;
      expect(toastContainer.children.length).toBe(0);
    });

    it('subscribes to error events on mount', () => {
      render(<ErrorToaster />);
      expect(errorEvents.onError).toHaveBeenCalledOnce();
    });

    it('unsubscribes from error events on unmount', () => {
      const { unmount } = render(<ErrorToaster />);
      expect(errorCallback).not.toBeNull();
      unmount();
      // After unmount, callback should be cleaned up
      expect(errorCallback).toBeNull();
    });
  });

  describe('toast display', () => {
    it('shows a toast when an error event is emitted', () => {
      render(<ErrorToaster />);

      act(() => {
        errorCallback!(createMockError({
          title: 'Network Error',
          description: 'Unable to reach server',
        }));
      });

      expect(screen.getByText('Network Error')).toBeInTheDocument();
      expect(screen.getByText('Unable to reach server')).toBeInTheDocument();
    });

    it('shows multiple toasts for multiple errors', () => {
      render(<ErrorToaster />);

      act(() => {
        errorCallback!(createMockError({ id: 'e1', title: 'Error 1' }));
        errorCallback!(createMockError({ id: 'e2', title: 'Error 2' }));
      });

      expect(screen.getByText('Error 1')).toBeInTheDocument();
      expect(screen.getByText('Error 2')).toBeInTheDocument();
    });

    it('limits toasts to MAX_TOASTS (3)', () => {
      render(<ErrorToaster />);

      act(() => {
        errorCallback!(createMockError({ id: 'e1', title: 'Error 1' }));
        errorCallback!(createMockError({ id: 'e2', title: 'Error 2' }));
        errorCallback!(createMockError({ id: 'e3', title: 'Error 3' }));
        errorCallback!(createMockError({ id: 'e4', title: 'Error 4' }));
      });

      // First toast should be removed, only last 3 remain
      expect(screen.queryByText('Error 1')).not.toBeInTheDocument();
      expect(screen.getByText('Error 2')).toBeInTheDocument();
      expect(screen.getByText('Error 3')).toBeInTheDocument();
      expect(screen.getByText('Error 4')).toBeInTheDocument();
    });
  });

  describe('toast dismissal', () => {
    it('auto-dismisses toast after delay', async () => {
      render(<ErrorToaster />);

      act(() => {
        errorCallback!(createMockError({ title: 'Temporary Error' }));
      });

      expect(screen.getByText('Temporary Error')).toBeInTheDocument();

      // Advance past the dismiss delay
      act(() => {
        vi.advanceTimersByTime(5001);
      });

      expect(screen.queryByText('Temporary Error')).not.toBeInTheDocument();
    });

    it('dismisses toast when X button is clicked', () => {
      render(<ErrorToaster />);

      act(() => {
        errorCallback!(createMockError({ title: 'Dismissable Error' }));
      });

      expect(screen.getByText('Dismissable Error')).toBeInTheDocument();

      const dismissButton = screen.getByLabelText('Dismiss');
      fireEvent.click(dismissButton);

      expect(screen.queryByText('Dismissable Error')).not.toBeInTheDocument();
    });

    it('only dismisses the clicked toast, not others', () => {
      render(<ErrorToaster />);

      act(() => {
        errorCallback!(createMockError({ id: 'e1', title: 'Keep This' }));
        errorCallback!(createMockError({ id: 'e2', title: 'Remove This' }));
      });

      // Click dismiss on the second toast
      const dismissButtons = screen.getAllByLabelText('Dismiss');
      fireEvent.click(dismissButtons[1]);

      expect(screen.getByText('Keep This')).toBeInTheDocument();
      expect(screen.queryByText('Remove This')).not.toBeInTheDocument();
    });
  });

  describe('error type rendering', () => {
    it('renders the correct icon for each error type', () => {
      render(<ErrorToaster />);

      act(() => {
        errorCallback!(createMockError({ type: 'auth', title: 'Auth Error' }));
      });

      expect(screen.getByText('Auth Error')).toBeInTheDocument();
      // Icon should be rendered (SVG element)
      const toastContent = screen.getByText('Auth Error').closest('div');
      expect(toastContent).toBeInTheDocument();
    });

    it('applies correct color classes for error type', () => {
      render(<ErrorToaster />);

      act(() => {
        errorCallback!(createMockError({ type: 'network', title: 'Network Issue' }));
      });

      expect(errorEvents.getColorForErrorType).toHaveBeenCalledWith('network');
    });
  });

  describe('positioning', () => {
    it('renders in fixed position at bottom-right', () => {
      const { container } = render(<ErrorToaster />);
      const wrapper = container.firstChild as HTMLElement;
      expect(wrapper).toHaveClass('fixed', 'z-50');
      expect(wrapper.style.bottom).toBe('24px');
      expect(wrapper.style.right).toBe('24px');
    });
  });
});
```

**Step 2: Run the test**

Run: `cd /Users/dhruv/aria/frontend && npx vitest run src/components/__tests__/ErrorToaster.test.tsx`
Expected: All tests PASS

**Step 3: Commit**

```bash
git add frontend/src/components/__tests__/ErrorToaster.test.tsx
git commit -m "test: US-930 add ErrorToaster component tests"
```

---

## Task 3: US-933 — Integrate FeedbackWidget into chat messages

**Files:**
- Modify: `frontend/src/components/chat/ChatMessage.tsx`

**Context:** The `FeedbackWidget` component already exists and is fully tested. The `ChatMessage` component renders ARIA's responses but doesn't include feedback buttons. We need to add `<FeedbackWidget>` to assistant messages (not user messages, not streaming messages).

**Step 1: Add FeedbackWidget import and render to ChatMessage**

In `frontend/src/components/chat/ChatMessage.tsx`, add the import:

```typescript
import { FeedbackWidget } from "@/components/FeedbackWidget";
```

Then add the FeedbackWidget after the timestamp div, inside the message container, only for non-user, non-streaming assistant messages:

After the timestamp `<div>` (the one with `mt-1.5`), add:

```tsx
        {/* Feedback widget for ARIA messages */}
        {!isUser && !isStreaming && message.content && (
          <div className="mt-1">
            <FeedbackWidget messageId={message.id} />
          </div>
        )}
```

**Step 2: Run type checking**

Run: `cd /Users/dhruv/aria/frontend && npx tsc --noEmit`
Expected: No type errors

**Step 3: Commit**

```bash
git add frontend/src/components/chat/ChatMessage.tsx
git commit -m "feat: US-933 integrate FeedbackWidget into ARIA chat messages"
```

---

## Task 4: US-933 — Deploy HelpTooltip across major feature pages

**Files:**
- Modify: `frontend/src/pages/Dashboard.tsx`
- Modify: `frontend/src/pages/Leads.tsx`
- Modify: `frontend/src/pages/Goals.tsx`
- Modify: `frontend/src/pages/BattleCards.tsx`
- Modify: `frontend/src/pages/MeetingBrief.tsx`
- Modify: `frontend/src/pages/EmailDrafts.tsx`
- Modify: `frontend/src/pages/Skills.tsx`
- Modify: `frontend/src/pages/AriaChat.tsx`
- Modify: `frontend/src/pages/IntegrationsSettings.tsx`
- Modify: `frontend/src/pages/AdminBillingPage.tsx`
- Modify: `frontend/src/pages/AdminTeamPage.tsx`
- Modify: `frontend/src/pages/SettingsAccountPage.tsx`
- Modify: `frontend/src/pages/SettingsPrivacyPage.tsx`

**Context:** `HelpTooltip` component exists at `frontend/src/components/HelpTooltip.tsx` and has tests but is never imported. We need to add it next to the page title/header of each major page. The pattern should be consistent: add `<HelpTooltip content="..."/>` next to the page heading.

**Step 1: Add HelpTooltip to each page**

For each page, import HelpTooltip and add it next to the page heading. The exact placement depends on each page's structure. General pattern:

```tsx
import { HelpTooltip } from "@/components/HelpTooltip";
```

Then add next to the page title. Here are the help content strings per page:

| Page | Help Content |
|------|-------------|
| Dashboard | "Your daily briefing from ARIA with key insights, tasks, and signals. Refreshes each morning." |
| Leads | "Track and manage your sales leads. ARIA monitors health scores and suggests next actions." |
| Goals | "Set objectives for ARIA to pursue. She'll track progress and suggest strategies." |
| BattleCards | "Competitive intelligence cards. ARIA keeps these updated with the latest market data." |
| MeetingBrief | "Pre-meeting preparation briefs. ARIA researches attendees and suggests talking points." |
| EmailDrafts | "AI-drafted emails from ARIA. Review, edit, and send from here." |
| Skills | "Extend ARIA's capabilities with specialized skills for your workflows." |
| AriaChat | "Chat directly with ARIA. Ask questions, request analysis, or give instructions." |
| IntegrationsSettings | "Connect your tools so ARIA can access your data and work across platforms." |
| AdminBillingPage | "Manage your subscription, view invoices, and update payment details." |
| AdminTeamPage | "Invite team members, manage roles, and configure company settings." |
| SettingsAccountPage | "Manage your profile, security settings, and account preferences." |
| SettingsPrivacyPage | "Control how ARIA uses your data. Export, delete, or adjust consent settings." |

The exact edit for each page will vary based on where the page title is rendered. Find the `<h1>` or main heading element and add `<HelpTooltip content="..." placement="right" />` next to it, wrapping both in a flex container if needed.

**Step 2: Run type checking**

Run: `cd /Users/dhruv/aria/frontend && npx tsc --noEmit`
Expected: No type errors

**Step 3: Commit**

```bash
git add frontend/src/pages/Dashboard.tsx frontend/src/pages/Leads.tsx frontend/src/pages/Goals.tsx frontend/src/pages/BattleCards.tsx frontend/src/pages/MeetingBrief.tsx frontend/src/pages/EmailDrafts.tsx frontend/src/pages/Skills.tsx frontend/src/pages/AriaChat.tsx frontend/src/pages/IntegrationsSettings.tsx frontend/src/pages/AdminBillingPage.tsx frontend/src/pages/AdminTeamPage.tsx frontend/src/pages/SettingsAccountPage.tsx frontend/src/pages/SettingsPrivacyPage.tsx
git commit -m "feat: US-933 add contextual help tooltips to all major feature pages"
```

---

## Task 5: Quality gates — run all tests and type checks

**Files:** None (verification only)

**Step 1: Run backend billing tests**

Run: `cd /Users/dhruv/aria && python -m pytest backend/tests/test_billing_service.py -v`
Expected: All PASS

**Step 2: Run frontend tests**

Run: `cd /Users/dhruv/aria/frontend && npx vitest run`
Expected: All PASS

**Step 3: Run type checking**

Run: `cd /Users/dhruv/aria/frontend && npx tsc --noEmit`
Expected: No errors

**Step 4: Run linters**

Run: `cd /Users/dhruv/aria && ruff check backend/src/ backend/tests/ && cd frontend && npx eslint src/`
Expected: No errors

**Step 5: Commit quality gate pass**

```bash
git commit --allow-empty -m "test: US-928 US-930 US-933 quality gates passed"
```
