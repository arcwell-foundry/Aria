# US-404, US-410, US-405 Migration Fix Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Create missing database migrations for daily_briefings and battle_cards tables, then verify frontend integration works.

**Architecture:** Both services (BriefingService, BattleCardService) are fully implemented but fail because their target tables don't exist. We need to create migrations following the existing patterns in the codebase (timestamp-based naming, RLS policies, service role bypass).

**Tech Stack:** PostgreSQL/Supabase, SQL migrations, RLS policies

---

## Task 1: Create Daily Briefings Migration (US-404)

**Files:**
- Create: `backend/supabase/migrations/20260203000001_create_daily_briefings.sql`

**Step 1: Create the migration file**

```sql
-- Daily briefings table for US-404: Daily Briefing Backend
-- Stores daily morning briefings with calendar, leads, signals, and tasks summary
-- Supports automatic generation and historical lookup

-- Main daily_briefings table
CREATE TABLE daily_briefings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    briefing_date DATE NOT NULL,
    content JSONB NOT NULL,
    generated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    delivered_at TIMESTAMPTZ,
    delivery_method TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    UNIQUE(user_id, briefing_date)
);

-- Add table comment
COMMENT ON TABLE daily_briefings IS 'Stores daily morning briefings containing calendar, leads, signals, and tasks summaries. One briefing per user per day.';

-- Create indexes for efficient querying
CREATE INDEX idx_daily_briefings_user_id ON daily_briefings(user_id);
CREATE INDEX idx_daily_briefings_date ON daily_briefings(briefing_date DESC);
CREATE INDEX idx_daily_briefings_user_date ON daily_briefings(user_id, briefing_date DESC);

-- Enable Row Level Security
ALTER TABLE daily_briefings ENABLE ROW LEVEL SECURITY;

-- RLS Policies for user isolation (multi-tenant)
CREATE POLICY "Users can view their own briefings" ON daily_briefings
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can create their own briefings" ON daily_briefings
    FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own briefings" ON daily_briefings
    FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own briefings" ON daily_briefings
    FOR DELETE USING (auth.uid() = user_id);

-- Service role bypass policy (for backend operations)
CREATE POLICY "Service role can manage daily_briefings" ON daily_briefings
    FOR ALL USING (auth.role() = 'service_role');
```

**Step 2: Verify the migration file was created**

Run: `ls -la backend/supabase/migrations/ | grep daily_briefings`
Expected: File `20260203000001_create_daily_briefings.sql` exists

**Step 3: Commit the migration**

```bash
git add backend/supabase/migrations/20260203000001_create_daily_briefings.sql
git commit -m "feat(db): add daily_briefings table migration for US-404

Creates the daily_briefings table with:
- User-scoped storage (one briefing per user per day)
- JSONB content for flexible briefing structure
- RLS policies for multi-tenant isolation
- Indexes for efficient date-based queries

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

## Task 2: Create Battle Cards Migration (US-410)

**Files:**
- Create: `backend/supabase/migrations/20260203000002_create_battle_cards.sql`

**Step 1: Create the migration file**

```sql
-- Battle cards tables for US-410: Battle Cards Backend
-- Stores competitive intelligence cards and tracks changes over time
-- Supports company-scoped storage with change history

-- Main battle_cards table
CREATE TABLE battle_cards (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    company_id UUID REFERENCES companies(id) ON DELETE CASCADE,
    competitor_name TEXT NOT NULL,
    competitor_domain TEXT,
    overview TEXT,
    strengths JSONB DEFAULT '[]',
    weaknesses JSONB DEFAULT '[]',
    pricing JSONB DEFAULT '{}',
    differentiation JSONB DEFAULT '[]',
    objection_handlers JSONB DEFAULT '[]',
    update_source TEXT DEFAULT 'manual',
    last_updated TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    UNIQUE(company_id, competitor_name)
);

-- Add table comment
COMMENT ON TABLE battle_cards IS 'Stores competitive intelligence cards for sales teams. One card per competitor per company.';

-- Battle card change history table
CREATE TABLE battle_card_changes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    battle_card_id UUID REFERENCES battle_cards(id) ON DELETE CASCADE NOT NULL,
    change_type TEXT NOT NULL,
    field_name TEXT,
    old_value JSONB,
    new_value JSONB,
    detected_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- Add table comment
COMMENT ON TABLE battle_card_changes IS 'Tracks all changes to battle cards for audit and history purposes.';

-- Create indexes for battle_cards
CREATE INDEX idx_battle_cards_company_id ON battle_cards(company_id);
CREATE INDEX idx_battle_cards_competitor_name ON battle_cards(competitor_name);
CREATE INDEX idx_battle_cards_last_updated ON battle_cards(last_updated DESC);

-- Create indexes for battle_card_changes
CREATE INDEX idx_battle_card_changes_card_id ON battle_card_changes(battle_card_id);
CREATE INDEX idx_battle_card_changes_detected_at ON battle_card_changes(detected_at DESC);

-- Enable Row Level Security
ALTER TABLE battle_cards ENABLE ROW LEVEL SECURITY;
ALTER TABLE battle_card_changes ENABLE ROW LEVEL SECURITY;

-- RLS Policies for battle_cards (company-scoped via user_profiles)
CREATE POLICY "Users can view battle cards for their company" ON battle_cards
    FOR SELECT USING (
        company_id IN (
            SELECT company_id FROM user_profiles WHERE id = auth.uid()
        )
    );

CREATE POLICY "Users can create battle cards for their company" ON battle_cards
    FOR INSERT WITH CHECK (
        company_id IN (
            SELECT company_id FROM user_profiles WHERE id = auth.uid()
        )
    );

CREATE POLICY "Users can update battle cards for their company" ON battle_cards
    FOR UPDATE USING (
        company_id IN (
            SELECT company_id FROM user_profiles WHERE id = auth.uid()
        )
    );

CREATE POLICY "Users can delete battle cards for their company" ON battle_cards
    FOR DELETE USING (
        company_id IN (
            SELECT company_id FROM user_profiles WHERE id = auth.uid()
        )
    );

-- RLS Policies for battle_card_changes (via battle_cards relationship)
CREATE POLICY "Users can view changes for their company battle cards" ON battle_card_changes
    FOR SELECT USING (
        battle_card_id IN (
            SELECT bc.id FROM battle_cards bc
            JOIN user_profiles up ON bc.company_id = up.company_id
            WHERE up.id = auth.uid()
        )
    );

CREATE POLICY "Users can create changes for their company battle cards" ON battle_card_changes
    FOR INSERT WITH CHECK (
        battle_card_id IN (
            SELECT bc.id FROM battle_cards bc
            JOIN user_profiles up ON bc.company_id = up.company_id
            WHERE up.id = auth.uid()
        )
    );

-- Service role bypass policies (for backend operations)
CREATE POLICY "Service role can manage battle_cards" ON battle_cards
    FOR ALL USING (auth.role() = 'service_role');

CREATE POLICY "Service role can manage battle_card_changes" ON battle_card_changes
    FOR ALL USING (auth.role() = 'service_role');
```

**Step 2: Verify the migration file was created**

Run: `ls -la backend/supabase/migrations/ | grep battle_cards`
Expected: File `20260203000002_create_battle_cards.sql` exists

**Step 3: Commit the migration**

```bash
git add backend/supabase/migrations/20260203000002_create_battle_cards.sql
git commit -m "feat(db): add battle_cards and battle_card_changes tables for US-410

Creates battle card tables with:
- Company-scoped storage (one card per competitor per company)
- Change history tracking for audit
- RLS policies scoped through user_profiles.company_id
- Indexes for efficient querying

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

## Task 3: Push Migrations to Supabase

**Files:**
- None (database operation)

**Step 1: Navigate to backend directory and push migrations**

Run: `cd /Users/dhruv/aria/backend && supabase db push`
Expected: Migrations applied successfully with output showing tables created

**Step 2: Verify tables exist**

Run: `cd /Users/dhruv/aria/backend && supabase db reset --dry-run | head -50`
Or check via Supabase dashboard that tables `daily_briefings`, `battle_cards`, and `battle_card_changes` exist.

---

## Task 4: Verify US-405 Frontend Integration

**Files:**
- Verify: `frontend/src/pages/Dashboard.tsx` (already implemented)
- Verify: `frontend/src/hooks/useBriefing.ts` (already implemented)
- Verify: `frontend/src/api/briefings.ts` (verify API functions)

**Step 1: Read the briefings API file to verify endpoint calls**

Run: Read `frontend/src/api/briefings.ts`
Expected: Should have `getTodayBriefing`, `getBriefingByDate`, `listBriefings`, `generateBriefing` functions that call the backend API

**Step 2: Start the frontend dev server (if not running)**

Run: `cd /Users/dhruv/aria/frontend && npm run dev`
Expected: Server starts on localhost

**Step 3: Start the backend server (if not running)**

Run: `cd /Users/dhruv/aria/backend && uvicorn src.main:app --reload --port 8000`
Expected: Server starts on port 8000

**Step 4: Manual verification checklist**

- [ ] Navigate to dashboard in browser
- [ ] Verify BriefingSkeleton shows during loading
- [ ] Verify BriefingEmpty shows when no briefing exists
- [ ] Click generate/refresh button and verify briefing generates
- [ ] Verify ExecutiveSummary renders summary text
- [ ] Verify CalendarSection renders (even if empty)
- [ ] Verify LeadsSection renders with hot_leads, needs_attention, recently_active
- [ ] Verify SignalsSection renders with company_news, market_trends, competitive_intel
- [ ] Verify TasksSection renders with overdue and due_today
- [ ] Click history button and verify modal opens
- [ ] Select a historical date and verify it loads (or shows empty state)

---

## Task 5: Run Type Checks and Linting

**Files:**
- None (verification only)

**Step 1: Run backend type checks**

Run: `cd /Users/dhruv/aria/backend && mypy src/ --strict`
Expected: No new errors (existing errors may be present)

**Step 2: Run backend linting**

Run: `cd /Users/dhruv/aria/backend && ruff check src/`
Expected: No new errors

**Step 3: Run frontend type checks**

Run: `cd /Users/dhruv/aria/frontend && npm run typecheck`
Expected: No errors

**Step 4: Run frontend linting**

Run: `cd /Users/dhruv/aria/frontend && npm run lint`
Expected: No errors

---

## Task 6: Write Integration Tests for Daily Briefings

**Files:**
- Create or modify: `backend/tests/test_briefings_integration.py`

**Step 1: Write the test file**

```python
"""Integration tests for briefings API endpoints."""

import pytest
from datetime import date
from httpx import AsyncClient


@pytest.mark.asyncio
async def test_get_today_briefing_generates_when_missing(
    client: AsyncClient,
    auth_headers: dict,
) -> None:
    """Test that GET /briefings/today generates a briefing if none exists."""
    response = await client.get("/api/briefings/today", headers=auth_headers)

    assert response.status_code == 200
    data = response.json()

    # Verify structure
    assert "summary" in data
    assert "calendar" in data
    assert "leads" in data
    assert "signals" in data
    assert "tasks" in data
    assert "generated_at" in data


@pytest.mark.asyncio
async def test_get_today_briefing_returns_existing(
    client: AsyncClient,
    auth_headers: dict,
) -> None:
    """Test that GET /briefings/today returns existing briefing."""
    # First call generates
    response1 = await client.get("/api/briefings/today", headers=auth_headers)
    assert response1.status_code == 200
    generated_at1 = response1.json()["generated_at"]

    # Second call returns existing (without regenerate flag)
    response2 = await client.get("/api/briefings/today", headers=auth_headers)
    assert response2.status_code == 200
    generated_at2 = response2.json()["generated_at"]

    assert generated_at1 == generated_at2


@pytest.mark.asyncio
async def test_regenerate_briefing(
    client: AsyncClient,
    auth_headers: dict,
) -> None:
    """Test that regenerate=true creates a fresh briefing."""
    # First call
    response1 = await client.get("/api/briefings/today", headers=auth_headers)
    generated_at1 = response1.json()["generated_at"]

    # Regenerate
    response2 = await client.get(
        "/api/briefings/today?regenerate=true",
        headers=auth_headers,
    )
    assert response2.status_code == 200
    generated_at2 = response2.json()["generated_at"]

    assert generated_at1 != generated_at2


@pytest.mark.asyncio
async def test_list_briefings(
    client: AsyncClient,
    auth_headers: dict,
) -> None:
    """Test listing recent briefings."""
    # Generate today's briefing first
    await client.get("/api/briefings/today", headers=auth_headers)

    # List briefings
    response = await client.get("/api/briefings", headers=auth_headers)
    assert response.status_code == 200

    data = response.json()
    assert isinstance(data, list)
    assert len(data) >= 1


@pytest.mark.asyncio
async def test_get_briefing_by_date_not_found(
    client: AsyncClient,
    auth_headers: dict,
) -> None:
    """Test that getting a non-existent date returns 404."""
    response = await client.get(
        "/api/briefings/2020-01-01",
        headers=auth_headers,
    )
    assert response.status_code == 404
```

**Step 2: Run the tests**

Run: `cd /Users/dhruv/aria/backend && pytest tests/test_briefings_integration.py -v`
Expected: All tests pass

**Step 3: Commit the tests**

```bash
git add backend/tests/test_briefings_integration.py
git commit -m "test: add integration tests for briefings API

Tests cover:
- Generating briefing when none exists
- Returning existing briefing
- Regenerating with fresh data
- Listing recent briefings
- 404 for non-existent dates

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

## Task 7: Write Integration Tests for Battle Cards

**Files:**
- Create or modify: `backend/tests/test_battle_cards_integration.py`

**Step 1: Write the test file**

```python
"""Integration tests for battle cards API endpoints."""

import pytest
from httpx import AsyncClient


@pytest.mark.asyncio
async def test_create_battle_card(
    client: AsyncClient,
    auth_headers: dict,
) -> None:
    """Test creating a battle card."""
    response = await client.post(
        "/api/battlecards/",
        headers=auth_headers,
        json={
            "competitor_name": "TestCompetitor",
            "overview": "A test competitor",
            "strengths": ["Strong brand"],
            "weaknesses": ["High prices"],
        },
    )

    assert response.status_code == 200
    data = response.json()

    assert data["competitor_name"] == "TestCompetitor"
    assert data["overview"] == "A test competitor"
    assert "id" in data


@pytest.mark.asyncio
async def test_list_battle_cards(
    client: AsyncClient,
    auth_headers: dict,
) -> None:
    """Test listing battle cards."""
    # Create a card first
    await client.post(
        "/api/battlecards/",
        headers=auth_headers,
        json={"competitor_name": "ListTestCompetitor"},
    )

    response = await client.get("/api/battlecards/", headers=auth_headers)
    assert response.status_code == 200

    data = response.json()
    assert isinstance(data, list)


@pytest.mark.asyncio
async def test_get_battle_card_by_name(
    client: AsyncClient,
    auth_headers: dict,
) -> None:
    """Test getting a battle card by competitor name."""
    # Create first
    await client.post(
        "/api/battlecards/",
        headers=auth_headers,
        json={"competitor_name": "GetTestCompetitor"},
    )

    response = await client.get(
        "/api/battlecards/GetTestCompetitor",
        headers=auth_headers,
    )
    assert response.status_code == 200
    assert response.json()["competitor_name"] == "GetTestCompetitor"


@pytest.mark.asyncio
async def test_update_battle_card(
    client: AsyncClient,
    auth_headers: dict,
) -> None:
    """Test updating a battle card."""
    # Create first
    create_response = await client.post(
        "/api/battlecards/",
        headers=auth_headers,
        json={"competitor_name": "UpdateTestCompetitor"},
    )
    card_id = create_response.json()["id"]

    # Update
    response = await client.patch(
        f"/api/battlecards/{card_id}",
        headers=auth_headers,
        json={"overview": "Updated overview"},
    )
    assert response.status_code == 200
    assert response.json()["overview"] == "Updated overview"


@pytest.mark.asyncio
async def test_get_card_history(
    client: AsyncClient,
    auth_headers: dict,
) -> None:
    """Test getting change history for a battle card."""
    # Create and update
    create_response = await client.post(
        "/api/battlecards/",
        headers=auth_headers,
        json={"competitor_name": "HistoryTestCompetitor"},
    )
    card_id = create_response.json()["id"]

    await client.patch(
        f"/api/battlecards/{card_id}",
        headers=auth_headers,
        json={"overview": "Changed overview"},
    )

    # Get history
    response = await client.get(
        f"/api/battlecards/{card_id}/history",
        headers=auth_headers,
    )
    assert response.status_code == 200

    data = response.json()
    assert isinstance(data, list)
    assert len(data) >= 1


@pytest.mark.asyncio
async def test_delete_battle_card(
    client: AsyncClient,
    auth_headers: dict,
) -> None:
    """Test deleting a battle card."""
    # Create first
    create_response = await client.post(
        "/api/battlecards/",
        headers=auth_headers,
        json={"competitor_name": "DeleteTestCompetitor"},
    )
    card_id = create_response.json()["id"]

    # Delete
    response = await client.delete(
        f"/api/battlecards/{card_id}",
        headers=auth_headers,
    )
    assert response.status_code == 200

    # Verify gone
    get_response = await client.get(
        "/api/battlecards/DeleteTestCompetitor",
        headers=auth_headers,
    )
    assert get_response.status_code == 404
```

**Step 2: Run the tests**

Run: `cd /Users/dhruv/aria/backend && pytest tests/test_battle_cards_integration.py -v`
Expected: All tests pass

**Step 3: Commit the tests**

```bash
git add backend/tests/test_battle_cards_integration.py
git commit -m "test: add integration tests for battle cards API

Tests cover:
- Creating battle cards
- Listing battle cards
- Getting by competitor name
- Updating cards with change tracking
- Getting change history
- Deleting cards

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

## Task 8: Final Verification and Cleanup

**Files:**
- None (verification only)

**Step 1: Run all backend tests**

Run: `cd /Users/dhruv/aria/backend && pytest tests/ -v`
Expected: All tests pass

**Step 2: Run git status to check for uncommitted changes**

Run: `git status`
Expected: Working tree clean or only expected untracked files

**Step 3: Document completion**

The following user stories should now be complete:
- **US-404**: Daily Briefing Backend - Migration created, service can now persist briefings
- **US-410**: Battle Cards Backend - Migration created, service can now manage battle cards
- **US-405**: Daily Briefing UI - Frontend was already complete, now works with backend

---

## Summary

| Task | Description | Files |
|------|-------------|-------|
| 1 | Create daily_briefings migration | `backend/supabase/migrations/20260203000001_create_daily_briefings.sql` |
| 2 | Create battle_cards migrations | `backend/supabase/migrations/20260203000002_create_battle_cards.sql` |
| 3 | Push migrations to Supabase | Database operation |
| 4 | Verify frontend integration | Manual testing |
| 5 | Run type checks and linting | Verification |
| 6 | Write briefings integration tests | `backend/tests/test_briefings_integration.py` |
| 7 | Write battle cards integration tests | `backend/tests/test_battle_cards_integration.py` |
| 8 | Final verification | Verification |

**Total estimated commits:** 4
