# US-408: Email Drafting Backend Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement ARIA's email drafting backend with Digital Twin style matching and Composio integration for sending.

**Architecture:** Create a new `drafts` router with full CRUD operations, a `DraftService` for business logic, and email generation via Claude. Drafts are stored in Supabase with RLS policies. The Digital Twin service provides style guidelines for LLM prompts, and style_match_score validates output. Sending uses existing Composio OAuth integration for Gmail/Outlook.

**Tech Stack:** FastAPI, Pydantic, Supabase (PostgreSQL), Anthropic Claude API, Composio OAuth, existing Digital Twin module

---

## Task 1: Create Database Schema

**Files:**
- Create: `backend/supabase/migrations/20260203_create_email_drafts.sql`

**Step 1: Write the SQL migration**

Create the migration file with the schema for email drafts:

```sql
-- Migration: Create email_drafts table
-- US-408: Email Drafting Backend

-- Create enum for draft purpose
CREATE TYPE email_purpose AS ENUM ('intro', 'follow_up', 'proposal', 'thank_you', 'check_in', 'other');

-- Create enum for draft tone
CREATE TYPE email_tone AS ENUM ('formal', 'friendly', 'urgent');

-- Create enum for draft status
CREATE TYPE email_draft_status AS ENUM ('draft', 'sent', 'failed');

-- Create email_drafts table
CREATE TABLE email_drafts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    recipient_email TEXT NOT NULL,
    recipient_name TEXT,
    subject TEXT NOT NULL,
    body TEXT NOT NULL,
    purpose email_purpose NOT NULL,
    tone email_tone DEFAULT 'friendly',
    context JSONB DEFAULT '{}',
    lead_memory_id UUID REFERENCES lead_memories(id) ON DELETE SET NULL,
    style_match_score FLOAT CHECK (style_match_score >= 0 AND style_match_score <= 1),
    status email_draft_status DEFAULT 'draft',
    sent_at TIMESTAMPTZ,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- Create indexes
CREATE INDEX idx_email_drafts_user_id ON email_drafts(user_id);
CREATE INDEX idx_email_drafts_status ON email_drafts(status);
CREATE INDEX idx_email_drafts_lead_memory_id ON email_drafts(lead_memory_id);
CREATE INDEX idx_email_drafts_created_at ON email_drafts(created_at DESC);

-- Enable RLS
ALTER TABLE email_drafts ENABLE ROW LEVEL SECURITY;

-- RLS Policies: Users can only access their own drafts
CREATE POLICY "Users can view their own drafts"
    ON email_drafts FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create their own drafts"
    ON email_drafts FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own drafts"
    ON email_drafts FOR UPDATE
    USING (auth.uid() = user_id)
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete their own drafts"
    ON email_drafts FOR DELETE
    USING (auth.uid() = user_id);

-- Trigger for updated_at
CREATE OR REPLACE FUNCTION update_email_drafts_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_email_drafts_updated_at
    BEFORE UPDATE ON email_drafts
    FOR EACH ROW
    EXECUTE FUNCTION update_email_drafts_updated_at();

-- Comment on table
COMMENT ON TABLE email_drafts IS 'Email drafts generated by ARIA with Digital Twin style matching';
```

**Step 2: Verify migration is syntactically correct**

Run: `cd backend && cat supabase/migrations/20260203_create_email_drafts.sql`
Expected: The SQL content without syntax errors.

**Step 3: Commit**

```bash
git add backend/supabase/migrations/20260203_create_email_drafts.sql
git commit -m "feat(db): add email_drafts table migration for US-408"
```

---

## Task 2: Create Pydantic Models for Email Drafts

**Files:**
- Create: `backend/src/models/email_draft.py`
- Modify: `backend/src/models/__init__.py`

**Step 1: Write the failing test**

Create test file `backend/tests/test_email_draft_schema.py`:

```python
"""Tests for email draft Pydantic models."""

from datetime import datetime

import pytest
from pydantic import ValidationError

from src.models.email_draft import (
    EmailDraftCreate,
    EmailDraftPurpose,
    EmailDraftResponse,
    EmailDraftStatus,
    EmailDraftTone,
    EmailDraftUpdate,
    EmailRegenerateRequest,
)


def test_email_draft_purpose_enum_values() -> None:
    """Test EmailDraftPurpose enum has all expected values."""
    assert EmailDraftPurpose.INTRO == "intro"
    assert EmailDraftPurpose.FOLLOW_UP == "follow_up"
    assert EmailDraftPurpose.PROPOSAL == "proposal"
    assert EmailDraftPurpose.THANK_YOU == "thank_you"
    assert EmailDraftPurpose.CHECK_IN == "check_in"
    assert EmailDraftPurpose.OTHER == "other"


def test_email_draft_tone_enum_values() -> None:
    """Test EmailDraftTone enum has all expected values."""
    assert EmailDraftTone.FORMAL == "formal"
    assert EmailDraftTone.FRIENDLY == "friendly"
    assert EmailDraftTone.URGENT == "urgent"


def test_email_draft_status_enum_values() -> None:
    """Test EmailDraftStatus enum has all expected values."""
    assert EmailDraftStatus.DRAFT == "draft"
    assert EmailDraftStatus.SENT == "sent"
    assert EmailDraftStatus.FAILED == "failed"


def test_email_draft_create_minimal() -> None:
    """Test EmailDraftCreate with minimal required fields."""
    draft = EmailDraftCreate(
        recipient_email="test@example.com",
        purpose=EmailDraftPurpose.INTRO,
    )
    assert draft.recipient_email == "test@example.com"
    assert draft.purpose == EmailDraftPurpose.INTRO
    assert draft.tone == EmailDraftTone.FRIENDLY  # default
    assert draft.subject_hint is None
    assert draft.context is None
    assert draft.lead_memory_id is None


def test_email_draft_create_full() -> None:
    """Test EmailDraftCreate with all fields."""
    draft = EmailDraftCreate(
        recipient_email="john@acme.com",
        recipient_name="John Smith",
        subject_hint="Follow up on our meeting",
        purpose=EmailDraftPurpose.FOLLOW_UP,
        context="We discussed pricing options",
        tone=EmailDraftTone.FORMAL,
        lead_memory_id="lead-123",
    )
    assert draft.recipient_email == "john@acme.com"
    assert draft.recipient_name == "John Smith"
    assert draft.subject_hint == "Follow up on our meeting"
    assert draft.purpose == EmailDraftPurpose.FOLLOW_UP
    assert draft.context == "We discussed pricing options"
    assert draft.tone == EmailDraftTone.FORMAL
    assert draft.lead_memory_id == "lead-123"


def test_email_draft_create_invalid_email() -> None:
    """Test EmailDraftCreate rejects invalid email."""
    with pytest.raises(ValidationError) as exc_info:
        EmailDraftCreate(
            recipient_email="not-an-email",
            purpose=EmailDraftPurpose.INTRO,
        )
    assert "email" in str(exc_info.value).lower()


def test_email_draft_update_partial() -> None:
    """Test EmailDraftUpdate allows partial updates."""
    update = EmailDraftUpdate(subject="New subject")
    assert update.subject == "New subject"
    assert update.body is None
    assert update.tone is None


def test_email_draft_update_all_fields() -> None:
    """Test EmailDraftUpdate with all fields."""
    update = EmailDraftUpdate(
        subject="Updated subject",
        body="Updated body content",
        tone=EmailDraftTone.URGENT,
        recipient_email="new@example.com",
    )
    assert update.subject == "Updated subject"
    assert update.body == "Updated body content"
    assert update.tone == EmailDraftTone.URGENT
    assert update.recipient_email == "new@example.com"


def test_email_draft_response_full() -> None:
    """Test EmailDraftResponse with all fields."""
    response = EmailDraftResponse(
        id="draft-123",
        user_id="user-456",
        recipient_email="test@example.com",
        recipient_name="Test User",
        subject="Test Subject",
        body="Test body content",
        purpose=EmailDraftPurpose.INTRO,
        tone=EmailDraftTone.FRIENDLY,
        context={"key": "value"},
        lead_memory_id="lead-789",
        style_match_score=0.85,
        status=EmailDraftStatus.DRAFT,
        sent_at=None,
        created_at=datetime.now(),
        updated_at=datetime.now(),
    )
    assert response.id == "draft-123"
    assert response.style_match_score == 0.85
    assert response.status == EmailDraftStatus.DRAFT


def test_email_regenerate_request_defaults() -> None:
    """Test EmailRegenerateRequest with defaults."""
    request = EmailRegenerateRequest()
    assert request.tone is None
    assert request.additional_context is None


def test_email_regenerate_request_custom() -> None:
    """Test EmailRegenerateRequest with custom values."""
    request = EmailRegenerateRequest(
        tone=EmailDraftTone.URGENT,
        additional_context="Make it more concise",
    )
    assert request.tone == EmailDraftTone.URGENT
    assert request.additional_context == "Make it more concise"
```

**Step 2: Run test to verify it fails**

Run: `cd backend && pytest tests/test_email_draft_schema.py -v`
Expected: FAIL with `ModuleNotFoundError: No module named 'src.models.email_draft'`

**Step 3: Write the email draft models**

Create `backend/src/models/email_draft.py`:

```python
"""Pydantic models for email drafts."""

from datetime import datetime
from enum import Enum
from typing import Any

from pydantic import BaseModel, EmailStr, Field


class EmailDraftPurpose(str, Enum):
    """Purpose categories for email drafts."""

    INTRO = "intro"
    FOLLOW_UP = "follow_up"
    PROPOSAL = "proposal"
    THANK_YOU = "thank_you"
    CHECK_IN = "check_in"
    OTHER = "other"


class EmailDraftTone(str, Enum):
    """Tone options for email drafts."""

    FORMAL = "formal"
    FRIENDLY = "friendly"
    URGENT = "urgent"


class EmailDraftStatus(str, Enum):
    """Status of an email draft."""

    DRAFT = "draft"
    SENT = "sent"
    FAILED = "failed"


class EmailDraftCreate(BaseModel):
    """Request model for creating an email draft."""

    recipient_email: EmailStr = Field(..., description="Recipient's email address")
    recipient_name: str | None = Field(None, description="Recipient's name for personalization")
    subject_hint: str | None = Field(None, description="Optional hint for subject line generation")
    purpose: EmailDraftPurpose = Field(..., description="Purpose of the email")
    context: str | None = Field(None, description="Additional context for draft generation")
    tone: EmailDraftTone = Field(EmailDraftTone.FRIENDLY, description="Desired tone")
    lead_memory_id: str | None = Field(None, description="Optional lead memory ID for context")


class EmailDraftUpdate(BaseModel):
    """Request model for updating an email draft."""

    recipient_email: EmailStr | None = Field(None, description="Updated recipient email")
    recipient_name: str | None = Field(None, description="Updated recipient name")
    subject: str | None = Field(None, description="Updated subject line")
    body: str | None = Field(None, description="Updated email body")
    tone: EmailDraftTone | None = Field(None, description="Updated tone")


class EmailDraftResponse(BaseModel):
    """Response model for an email draft."""

    id: str = Field(..., description="Draft ID")
    user_id: str = Field(..., description="Owner user ID")
    recipient_email: str = Field(..., description="Recipient's email address")
    recipient_name: str | None = Field(None, description="Recipient's name")
    subject: str = Field(..., description="Email subject line")
    body: str = Field(..., description="Email body content")
    purpose: EmailDraftPurpose = Field(..., description="Purpose of the email")
    tone: EmailDraftTone = Field(..., description="Tone of the email")
    context: dict[str, Any] | None = Field(None, description="Context used for generation")
    lead_memory_id: str | None = Field(None, description="Associated lead memory ID")
    style_match_score: float | None = Field(
        None, ge=0.0, le=1.0, description="How well the draft matches user's style"
    )
    status: EmailDraftStatus = Field(..., description="Current status of the draft")
    sent_at: datetime | None = Field(None, description="When the email was sent")
    error_message: str | None = Field(None, description="Error message if sending failed")
    created_at: datetime = Field(..., description="Creation timestamp")
    updated_at: datetime = Field(..., description="Last update timestamp")


class EmailDraftListResponse(BaseModel):
    """Response model for listing email drafts."""

    id: str
    recipient_email: str
    recipient_name: str | None
    subject: str
    purpose: EmailDraftPurpose
    tone: EmailDraftTone
    status: EmailDraftStatus
    style_match_score: float | None
    created_at: datetime


class EmailRegenerateRequest(BaseModel):
    """Request model for regenerating an email draft."""

    tone: EmailDraftTone | None = Field(None, description="New tone for regeneration")
    additional_context: str | None = Field(None, description="Additional context for regeneration")


class EmailSendResponse(BaseModel):
    """Response model for sending an email."""

    id: str = Field(..., description="Draft ID")
    status: EmailDraftStatus = Field(..., description="New status after send attempt")
    sent_at: datetime | None = Field(None, description="When email was sent")
    error_message: str | None = Field(None, description="Error if send failed")
```

**Step 4: Update models __init__.py**

Add to `backend/src/models/__init__.py`:

```python
from src.models.email_draft import (
    EmailDraftCreate,
    EmailDraftListResponse,
    EmailDraftPurpose,
    EmailDraftResponse,
    EmailDraftStatus,
    EmailDraftTone,
    EmailDraftUpdate,
    EmailRegenerateRequest,
    EmailSendResponse,
)
```

**Step 5: Run tests to verify they pass**

Run: `cd backend && pytest tests/test_email_draft_schema.py -v`
Expected: All 11 tests PASS

**Step 6: Run type checker**

Run: `cd backend && mypy src/models/email_draft.py --strict`
Expected: Success: no issues found

**Step 7: Commit**

```bash
git add backend/src/models/email_draft.py backend/src/models/__init__.py backend/tests/test_email_draft_schema.py
git commit -m "feat(models): add email draft Pydantic models for US-408"
```

---

## Task 3: Create Email Draft Exception

**Files:**
- Modify: `backend/src/core/exceptions.py`

**Step 1: Write the failing test**

Create `backend/tests/test_email_draft_exceptions.py`:

```python
"""Tests for email draft exceptions."""

from src.core.exceptions import EmailDraftError, EmailSendError


def test_email_draft_error_basic() -> None:
    """Test EmailDraftError basic creation."""
    error = EmailDraftError("Generation failed")
    assert error.message == "Email draft operation failed: Generation failed"
    assert error.code == "EMAIL_DRAFT_ERROR"
    assert error.status_code == 500


def test_email_draft_error_with_details() -> None:
    """Test EmailDraftError with details."""
    error = EmailDraftError("Invalid recipient", details={"recipient": "bad@"})
    assert "Email draft operation failed" in error.message
    assert error.details == {"recipient": "bad@"}


def test_email_send_error_basic() -> None:
    """Test EmailSendError basic creation."""
    error = EmailSendError("SMTP timeout")
    assert error.message == "Email send failed: SMTP timeout"
    assert error.code == "EMAIL_SEND_ERROR"
    assert error.status_code == 502


def test_email_send_error_with_draft_id() -> None:
    """Test EmailSendError with draft ID."""
    error = EmailSendError("Connection refused", draft_id="draft-123")
    assert error.details["draft_id"] == "draft-123"
```

**Step 2: Run test to verify it fails**

Run: `cd backend && pytest tests/test_email_draft_exceptions.py -v`
Expected: FAIL with `ImportError: cannot import name 'EmailDraftError'`

**Step 3: Add exceptions to exceptions.py**

Add to `backend/src/core/exceptions.py`:

```python
class EmailDraftError(ARIAException):
    """Exception for email draft generation errors."""

    def __init__(
        self,
        message: str = "Unknown error",
        details: dict[str, Any] | None = None,
    ) -> None:
        super().__init__(
            message=f"Email draft operation failed: {message}",
            code="EMAIL_DRAFT_ERROR",
            status_code=500,
            details=details,
        )


class EmailSendError(ARIAException):
    """Exception for email sending errors."""

    def __init__(
        self,
        message: str = "Unknown error",
        draft_id: str | None = None,
        details: dict[str, Any] | None = None,
    ) -> None:
        error_details = details or {}
        if draft_id:
            error_details["draft_id"] = draft_id
        super().__init__(
            message=f"Email send failed: {message}",
            code="EMAIL_SEND_ERROR",
            status_code=502,
            details=error_details,
        )
```

**Step 4: Run tests to verify they pass**

Run: `cd backend && pytest tests/test_email_draft_exceptions.py -v`
Expected: All 4 tests PASS

**Step 5: Commit**

```bash
git add backend/src/core/exceptions.py backend/tests/test_email_draft_exceptions.py
git commit -m "feat(exceptions): add EmailDraftError and EmailSendError for US-408"
```

---

## Task 4: Create Email Draft Service

**Files:**
- Create: `backend/src/services/draft_service.py`

**Step 1: Write the failing test**

Create `backend/tests/test_draft_service.py`:

```python
"""Tests for email draft service."""

from datetime import UTC, datetime
from unittest.mock import AsyncMock, MagicMock, patch

import pytest

from src.models.email_draft import EmailDraftPurpose, EmailDraftTone
from src.services.draft_service import DraftService


@pytest.fixture
def draft_service() -> DraftService:
    """Create DraftService instance."""
    return DraftService()


@pytest.fixture
def mock_db() -> MagicMock:
    """Create mock Supabase client."""
    return MagicMock()


@pytest.fixture
def sample_draft_data() -> dict:
    """Sample draft data from database."""
    return {
        "id": "draft-123",
        "user_id": "user-456",
        "recipient_email": "test@example.com",
        "recipient_name": "Test User",
        "subject": "Hello",
        "body": "Hi there, this is a test email.",
        "purpose": "intro",
        "tone": "friendly",
        "context": {},
        "lead_memory_id": None,
        "style_match_score": 0.85,
        "status": "draft",
        "sent_at": None,
        "error_message": None,
        "created_at": datetime.now(UTC).isoformat(),
        "updated_at": datetime.now(UTC).isoformat(),
    }


@pytest.mark.asyncio
async def test_create_draft_generates_email(
    draft_service: DraftService,
    mock_db: MagicMock,
) -> None:
    """Test create_draft generates email content via LLM."""
    with patch("src.services.draft_service.SupabaseClient") as mock_db_class, \
         patch("src.services.draft_service.LLMClient") as mock_llm_class, \
         patch("src.services.draft_service.DigitalTwin") as mock_twin_class:

        # Setup DB mock
        mock_db_class.get_client.return_value = mock_db
        mock_db.table.return_value.insert.return_value.execute.return_value = MagicMock(
            data=[{
                "id": "draft-123",
                "user_id": "user-456",
                "recipient_email": "test@example.com",
                "recipient_name": None,
                "subject": "Introduction",
                "body": "Hello, I wanted to introduce myself...",
                "purpose": "intro",
                "tone": "friendly",
                "context": {},
                "lead_memory_id": None,
                "style_match_score": 0.85,
                "status": "draft",
                "sent_at": None,
                "error_message": None,
                "created_at": "2026-02-03T10:00:00Z",
                "updated_at": "2026-02-03T10:00:00Z",
            }]
        )

        # Setup LLM mock
        mock_llm = AsyncMock()
        mock_llm.generate_response = AsyncMock(
            return_value='{"subject": "Introduction", "body": "Hello, I wanted to introduce myself..."}'
        )
        mock_llm_class.return_value = mock_llm

        # Setup Digital Twin mock
        mock_twin = AsyncMock()
        mock_twin.get_style_guidelines = AsyncMock(return_value="Write in a friendly tone.")
        mock_twin.score_style_match = AsyncMock(return_value=0.85)
        mock_twin_class.return_value = mock_twin

        result = await draft_service.create_draft(
            user_id="user-456",
            recipient_email="test@example.com",
            purpose=EmailDraftPurpose.INTRO,
            tone=EmailDraftTone.FRIENDLY,
        )

        assert result["id"] == "draft-123"
        assert result["subject"] == "Introduction"
        assert "body" in result
        mock_llm.generate_response.assert_called_once()


@pytest.mark.asyncio
async def test_get_draft_returns_draft(
    draft_service: DraftService,
    mock_db: MagicMock,
    sample_draft_data: dict,
) -> None:
    """Test get_draft returns draft by ID."""
    with patch("src.services.draft_service.SupabaseClient") as mock_db_class:
        mock_db_class.get_client.return_value = mock_db
        mock_db.table.return_value.select.return_value.eq.return_value.eq.return_value.single.return_value.execute.return_value = MagicMock(
            data=sample_draft_data
        )

        result = await draft_service.get_draft("user-456", "draft-123")

        assert result is not None
        assert result["id"] == "draft-123"


@pytest.mark.asyncio
async def test_get_draft_returns_none_when_not_found(
    draft_service: DraftService,
    mock_db: MagicMock,
) -> None:
    """Test get_draft returns None when draft not found."""
    with patch("src.services.draft_service.SupabaseClient") as mock_db_class:
        mock_db_class.get_client.return_value = mock_db
        mock_db.table.return_value.select.return_value.eq.return_value.eq.return_value.single.return_value.execute.return_value = MagicMock(
            data=None
        )

        result = await draft_service.get_draft("user-456", "nonexistent")

        assert result is None


@pytest.mark.asyncio
async def test_list_drafts_returns_user_drafts(
    draft_service: DraftService,
    mock_db: MagicMock,
    sample_draft_data: dict,
) -> None:
    """Test list_drafts returns all user's drafts."""
    with patch("src.services.draft_service.SupabaseClient") as mock_db_class:
        mock_db_class.get_client.return_value = mock_db
        mock_db.table.return_value.select.return_value.eq.return_value.order.return_value.limit.return_value.execute.return_value = MagicMock(
            data=[sample_draft_data]
        )

        result = await draft_service.list_drafts("user-456")

        assert len(result) == 1
        assert result[0]["id"] == "draft-123"


@pytest.mark.asyncio
async def test_update_draft_updates_fields(
    draft_service: DraftService,
    mock_db: MagicMock,
    sample_draft_data: dict,
) -> None:
    """Test update_draft updates specified fields."""
    updated_data = sample_draft_data.copy()
    updated_data["subject"] = "Updated Subject"

    with patch("src.services.draft_service.SupabaseClient") as mock_db_class:
        mock_db_class.get_client.return_value = mock_db
        mock_db.table.return_value.update.return_value.eq.return_value.eq.return_value.execute.return_value = MagicMock(
            data=[updated_data]
        )

        result = await draft_service.update_draft(
            user_id="user-456",
            draft_id="draft-123",
            updates={"subject": "Updated Subject"},
        )

        assert result["subject"] == "Updated Subject"


@pytest.mark.asyncio
async def test_delete_draft_removes_draft(
    draft_service: DraftService,
    mock_db: MagicMock,
) -> None:
    """Test delete_draft removes draft."""
    with patch("src.services.draft_service.SupabaseClient") as mock_db_class:
        mock_db_class.get_client.return_value = mock_db
        mock_db.table.return_value.delete.return_value.eq.return_value.eq.return_value.execute.return_value = MagicMock()

        result = await draft_service.delete_draft("user-456", "draft-123")

        assert result is True


@pytest.mark.asyncio
async def test_regenerate_draft_creates_new_version(
    draft_service: DraftService,
    mock_db: MagicMock,
    sample_draft_data: dict,
) -> None:
    """Test regenerate_draft creates new version with same parameters."""
    with patch("src.services.draft_service.SupabaseClient") as mock_db_class, \
         patch("src.services.draft_service.LLMClient") as mock_llm_class, \
         patch("src.services.draft_service.DigitalTwin") as mock_twin_class:

        mock_db_class.get_client.return_value = mock_db

        # First call returns original draft
        mock_db.table.return_value.select.return_value.eq.return_value.eq.return_value.single.return_value.execute.return_value = MagicMock(
            data=sample_draft_data
        )

        # Update call returns regenerated draft
        regenerated = sample_draft_data.copy()
        regenerated["body"] = "New regenerated body"
        mock_db.table.return_value.update.return_value.eq.return_value.eq.return_value.execute.return_value = MagicMock(
            data=[regenerated]
        )

        mock_llm = AsyncMock()
        mock_llm.generate_response = AsyncMock(
            return_value='{"subject": "Hello", "body": "New regenerated body"}'
        )
        mock_llm_class.return_value = mock_llm

        mock_twin = AsyncMock()
        mock_twin.get_style_guidelines = AsyncMock(return_value="Write friendly.")
        mock_twin.score_style_match = AsyncMock(return_value=0.90)
        mock_twin_class.return_value = mock_twin

        result = await draft_service.regenerate_draft(
            user_id="user-456",
            draft_id="draft-123",
        )

        assert result["body"] == "New regenerated body"


@pytest.mark.asyncio
async def test_create_draft_with_lead_context(
    draft_service: DraftService,
    mock_db: MagicMock,
) -> None:
    """Test create_draft pulls context from lead memory."""
    with patch("src.services.draft_service.SupabaseClient") as mock_db_class, \
         patch("src.services.draft_service.LLMClient") as mock_llm_class, \
         patch("src.services.draft_service.DigitalTwin") as mock_twin_class:

        mock_db_class.get_client.return_value = mock_db

        # Mock lead_memories query
        mock_db.table.return_value.select.return_value.eq.return_value.eq.return_value.single.return_value.execute.return_value = MagicMock(
            data={
                "id": "lead-123",
                "company_name": "Acme Corp",
                "lifecycle_stage": "opportunity",
                "status": "active",
            }
        )

        mock_db.table.return_value.insert.return_value.execute.return_value = MagicMock(
            data=[{
                "id": "draft-123",
                "user_id": "user-456",
                "recipient_email": "john@acme.com",
                "recipient_name": None,
                "subject": "Follow up on Acme Corp",
                "body": "Hi, following up on our conversation about Acme Corp...",
                "purpose": "follow_up",
                "tone": "friendly",
                "context": {"lead_company": "Acme Corp"},
                "lead_memory_id": "lead-123",
                "style_match_score": 0.82,
                "status": "draft",
                "sent_at": None,
                "error_message": None,
                "created_at": "2026-02-03T10:00:00Z",
                "updated_at": "2026-02-03T10:00:00Z",
            }]
        )

        mock_llm = AsyncMock()
        mock_llm.generate_response = AsyncMock(
            return_value='{"subject": "Follow up on Acme Corp", "body": "Hi, following up on our conversation about Acme Corp..."}'
        )
        mock_llm_class.return_value = mock_llm

        mock_twin = AsyncMock()
        mock_twin.get_style_guidelines = AsyncMock(return_value="Write friendly.")
        mock_twin.score_style_match = AsyncMock(return_value=0.82)
        mock_twin_class.return_value = mock_twin

        result = await draft_service.create_draft(
            user_id="user-456",
            recipient_email="john@acme.com",
            purpose=EmailDraftPurpose.FOLLOW_UP,
            tone=EmailDraftTone.FRIENDLY,
            lead_memory_id="lead-123",
        )

        assert result["lead_memory_id"] == "lead-123"
        assert "Acme Corp" in result["subject"]
```

**Step 2: Run test to verify it fails**

Run: `cd backend && pytest tests/test_draft_service.py -v`
Expected: FAIL with `ModuleNotFoundError: No module named 'src.services.draft_service'`

**Step 3: Write the draft service**

Create `backend/src/services/draft_service.py`:

```python
"""Service for email draft generation and management."""

import json
import logging
from datetime import UTC, datetime
from typing import Any, cast

from src.core.exceptions import EmailDraftError, NotFoundError
from src.core.llm import LLMClient
from src.db.supabase import SupabaseClient
from src.memory.digital_twin import DigitalTwin
from src.models.email_draft import EmailDraftPurpose, EmailDraftTone

logger = logging.getLogger(__name__)

# System prompt for email generation
EMAIL_GENERATION_PROMPT = """You are ARIA, an AI assistant helping a sales professional draft emails.
Generate a professional email based on the following parameters.

IMPORTANT: Your response MUST be valid JSON with exactly two fields:
{
  "subject": "The email subject line",
  "body": "The full email body"
}

Do not include any text outside the JSON object.
"""

PURPOSE_DESCRIPTIONS = {
    EmailDraftPurpose.INTRO: "an introduction email to establish initial contact",
    EmailDraftPurpose.FOLLOW_UP: "a follow-up email to continue a previous conversation",
    EmailDraftPurpose.PROPOSAL: "a proposal email presenting an offer or solution",
    EmailDraftPurpose.THANK_YOU: "a thank you email expressing gratitude",
    EmailDraftPurpose.CHECK_IN: "a check-in email to maintain the relationship",
    EmailDraftPurpose.OTHER: "a general business email",
}

TONE_INSTRUCTIONS = {
    EmailDraftTone.FORMAL: "Use formal, professional language. Avoid contractions and casual expressions.",
    EmailDraftTone.FRIENDLY: "Use warm, approachable language while remaining professional.",
    EmailDraftTone.URGENT: "Convey urgency and importance. Be direct and action-oriented.",
}


class DraftService:
    """Service for managing email drafts."""

    def __init__(self) -> None:
        """Initialize the draft service."""
        self._llm = LLMClient()
        self._digital_twin = DigitalTwin()

    async def create_draft(
        self,
        user_id: str,
        recipient_email: str,
        purpose: EmailDraftPurpose,
        tone: EmailDraftTone = EmailDraftTone.FRIENDLY,
        recipient_name: str | None = None,
        subject_hint: str | None = None,
        context: str | None = None,
        lead_memory_id: str | None = None,
    ) -> dict[str, Any]:
        """Create a new email draft using LLM generation.

        Args:
            user_id: The user's ID
            recipient_email: Recipient's email address
            purpose: Purpose of the email
            tone: Desired tone
            recipient_name: Optional recipient name
            subject_hint: Optional hint for subject line
            context: Optional additional context
            lead_memory_id: Optional lead memory ID for context

        Returns:
            Created draft dictionary

        Raises:
            EmailDraftError: If generation fails
        """
        try:
            # Gather context from lead memory if provided
            lead_context = await self._get_lead_context(user_id, lead_memory_id)

            # Get user's writing style guidelines
            style_guidelines = await self._digital_twin.get_style_guidelines(user_id)

            # Build generation prompt
            generation_prompt = self._build_generation_prompt(
                recipient_email=recipient_email,
                recipient_name=recipient_name,
                purpose=purpose,
                tone=tone,
                subject_hint=subject_hint,
                context=context,
                lead_context=lead_context,
                style_guidelines=style_guidelines,
            )

            # Generate email content
            response = await self._llm.generate_response(
                messages=[{"role": "user", "content": generation_prompt}],
                system_prompt=EMAIL_GENERATION_PROMPT,
                temperature=0.7,
            )

            # Parse JSON response
            try:
                email_content = json.loads(response)
                subject = email_content.get("subject", "")
                body = email_content.get("body", "")
            except json.JSONDecodeError:
                # Fallback: try to extract content
                logger.warning("Failed to parse JSON response, using fallback")
                subject = subject_hint or "Email from ARIA"
                body = response

            # Score style match
            style_score = await self._digital_twin.score_style_match(user_id, body)

            # Store draft in database
            client = SupabaseClient.get_client()
            draft_data = {
                "user_id": user_id,
                "recipient_email": recipient_email,
                "recipient_name": recipient_name,
                "subject": subject,
                "body": body,
                "purpose": purpose.value,
                "tone": tone.value,
                "context": {"user_context": context, "lead_context": lead_context},
                "lead_memory_id": lead_memory_id,
                "style_match_score": style_score,
                "status": "draft",
            }

            result = client.table("email_drafts").insert(draft_data).execute()

            if not result.data or len(result.data) == 0:
                raise EmailDraftError("Failed to store draft in database")

            logger.info(
                "Email draft created",
                extra={
                    "user_id": user_id,
                    "draft_id": result.data[0]["id"],
                    "purpose": purpose.value,
                    "style_score": style_score,
                },
            )

            return cast(dict[str, Any], result.data[0])

        except EmailDraftError:
            raise
        except Exception as e:
            logger.exception("Failed to create email draft")
            raise EmailDraftError(str(e)) from e

    async def get_draft(self, user_id: str, draft_id: str) -> dict[str, Any] | None:
        """Get a specific draft by ID.

        Args:
            user_id: The user's ID
            draft_id: The draft ID

        Returns:
            Draft dictionary or None if not found
        """
        try:
            client = SupabaseClient.get_client()
            result = (
                client.table("email_drafts")
                .select("*")
                .eq("id", draft_id)
                .eq("user_id", user_id)
                .single()
                .execute()
            )

            if result.data is None:
                return None

            return cast(dict[str, Any], result.data)

        except Exception:
            logger.exception("Failed to get draft")
            return None

    async def list_drafts(
        self,
        user_id: str,
        limit: int = 50,
        status: str | None = None,
    ) -> list[dict[str, Any]]:
        """List user's drafts.

        Args:
            user_id: The user's ID
            limit: Maximum number of drafts to return
            status: Optional filter by status

        Returns:
            List of draft dictionaries
        """
        try:
            client = SupabaseClient.get_client()
            query = client.table("email_drafts").select("*").eq("user_id", user_id)

            if status:
                query = query.eq("status", status)

            result = query.order("created_at", desc=True).limit(limit).execute()

            return cast(list[dict[str, Any]], result.data) if result.data else []

        except Exception:
            logger.exception("Failed to list drafts")
            return []

    async def update_draft(
        self,
        user_id: str,
        draft_id: str,
        updates: dict[str, Any],
    ) -> dict[str, Any]:
        """Update a draft.

        Args:
            user_id: The user's ID
            draft_id: The draft ID
            updates: Fields to update

        Returns:
            Updated draft dictionary

        Raises:
            NotFoundError: If draft not found
            EmailDraftError: If update fails
        """
        try:
            client = SupabaseClient.get_client()

            # Filter out None values
            filtered_updates = {k: v for k, v in updates.items() if v is not None}

            if not filtered_updates:
                # No updates to make, return existing draft
                draft = await self.get_draft(user_id, draft_id)
                if draft is None:
                    raise NotFoundError("Draft", draft_id)
                return draft

            result = (
                client.table("email_drafts")
                .update(filtered_updates)
                .eq("id", draft_id)
                .eq("user_id", user_id)
                .execute()
            )

            if not result.data or len(result.data) == 0:
                raise NotFoundError("Draft", draft_id)

            logger.info(
                "Email draft updated",
                extra={"user_id": user_id, "draft_id": draft_id},
            )

            return cast(dict[str, Any], result.data[0])

        except NotFoundError:
            raise
        except Exception as e:
            logger.exception("Failed to update draft")
            raise EmailDraftError(str(e)) from e

    async def delete_draft(self, user_id: str, draft_id: str) -> bool:
        """Delete a draft.

        Args:
            user_id: The user's ID
            draft_id: The draft ID

        Returns:
            True if deleted successfully
        """
        try:
            client = SupabaseClient.get_client()
            client.table("email_drafts").delete().eq("id", draft_id).eq(
                "user_id", user_id
            ).execute()

            logger.info(
                "Email draft deleted",
                extra={"user_id": user_id, "draft_id": draft_id},
            )

            return True

        except Exception:
            logger.exception("Failed to delete draft")
            return False

    async def regenerate_draft(
        self,
        user_id: str,
        draft_id: str,
        tone: EmailDraftTone | None = None,
        additional_context: str | None = None,
    ) -> dict[str, Any]:
        """Regenerate a draft with new parameters.

        Args:
            user_id: The user's ID
            draft_id: The draft ID to regenerate
            tone: Optional new tone
            additional_context: Optional additional context

        Returns:
            Regenerated draft dictionary

        Raises:
            NotFoundError: If draft not found
            EmailDraftError: If regeneration fails
        """
        try:
            # Get existing draft
            draft = await self.get_draft(user_id, draft_id)
            if draft is None:
                raise NotFoundError("Draft", draft_id)

            # Use new tone if provided, otherwise keep original
            use_tone = tone if tone else EmailDraftTone(draft["tone"])

            # Gather context
            lead_context = await self._get_lead_context(user_id, draft.get("lead_memory_id"))
            style_guidelines = await self._digital_twin.get_style_guidelines(user_id)

            # Combine contexts
            original_context = draft.get("context", {}).get("user_context", "")
            combined_context = f"{original_context}\n{additional_context}" if additional_context else original_context

            # Build generation prompt
            generation_prompt = self._build_generation_prompt(
                recipient_email=draft["recipient_email"],
                recipient_name=draft.get("recipient_name"),
                purpose=EmailDraftPurpose(draft["purpose"]),
                tone=use_tone,
                subject_hint=None,
                context=combined_context,
                lead_context=lead_context,
                style_guidelines=style_guidelines,
            )

            # Generate new content
            response = await self._llm.generate_response(
                messages=[{"role": "user", "content": generation_prompt}],
                system_prompt=EMAIL_GENERATION_PROMPT,
                temperature=0.8,  # Slightly higher for variety
            )

            # Parse response
            try:
                email_content = json.loads(response)
                subject = email_content.get("subject", draft["subject"])
                body = email_content.get("body", "")
            except json.JSONDecodeError:
                subject = draft["subject"]
                body = response

            # Score style match
            style_score = await self._digital_twin.score_style_match(user_id, body)

            # Update draft
            updates = {
                "subject": subject,
                "body": body,
                "tone": use_tone.value,
                "style_match_score": style_score,
            }

            return await self.update_draft(user_id, draft_id, updates)

        except NotFoundError:
            raise
        except Exception as e:
            logger.exception("Failed to regenerate draft")
            raise EmailDraftError(str(e)) from e

    async def _get_lead_context(
        self,
        user_id: str,
        lead_memory_id: str | None,
    ) -> dict[str, Any] | None:
        """Get context from lead memory.

        Args:
            user_id: The user's ID
            lead_memory_id: The lead memory ID

        Returns:
            Lead context dictionary or None
        """
        if not lead_memory_id:
            return None

        try:
            client = SupabaseClient.get_client()
            result = (
                client.table("lead_memories")
                .select("*")
                .eq("id", lead_memory_id)
                .eq("user_id", user_id)
                .single()
                .execute()
            )

            if result.data:
                return cast(dict[str, Any], result.data)
            return None

        except Exception:
            logger.warning(f"Failed to get lead context for {lead_memory_id}")
            return None

    def _build_generation_prompt(
        self,
        recipient_email: str,
        recipient_name: str | None,
        purpose: EmailDraftPurpose,
        tone: EmailDraftTone,
        subject_hint: str | None,
        context: str | None,
        lead_context: dict[str, Any] | None,
        style_guidelines: str,
    ) -> str:
        """Build the prompt for email generation.

        Args:
            recipient_email: Recipient's email
            recipient_name: Recipient's name
            purpose: Email purpose
            tone: Desired tone
            subject_hint: Optional subject hint
            context: Additional context
            lead_context: Lead memory context
            style_guidelines: User's style guidelines

        Returns:
            Complete generation prompt
        """
        parts = [
            f"Generate {PURPOSE_DESCRIPTIONS[purpose]}.",
            "",
            f"Recipient: {recipient_name or recipient_email}",
            f"Tone: {TONE_INSTRUCTIONS[tone]}",
        ]

        if subject_hint:
            parts.append(f"Subject hint: {subject_hint}")

        if context:
            parts.append(f"\nAdditional context: {context}")

        if lead_context:
            company = lead_context.get("company_name", "")
            stage = lead_context.get("lifecycle_stage", "")
            if company:
                parts.append(f"\nCompany: {company}")
            if stage:
                parts.append(f"Relationship stage: {stage}")

        parts.append(f"\n--- WRITING STYLE GUIDELINES ---\n{style_guidelines}")

        return "\n".join(parts)


# Singleton instance
_draft_service: DraftService | None = None


def get_draft_service() -> DraftService:
    """Get or create draft service singleton.

    Returns:
        The shared DraftService instance
    """
    global _draft_service
    if _draft_service is None:
        _draft_service = DraftService()
    return _draft_service
```

**Step 4: Run tests to verify they pass**

Run: `cd backend && pytest tests/test_draft_service.py -v`
Expected: All 10 tests PASS

**Step 5: Run type checker**

Run: `cd backend && mypy src/services/draft_service.py --strict`
Expected: Success: no issues found

**Step 6: Commit**

```bash
git add backend/src/services/draft_service.py backend/tests/test_draft_service.py
git commit -m "feat(services): add DraftService for email draft generation - US-408"
```

---

## Task 5: Create Email Sending Service

**Files:**
- Modify: `backend/src/services/draft_service.py`
- Modify: `backend/src/integrations/oauth.py`

**Step 1: Write the failing test**

Add to `backend/tests/test_draft_service.py`:

```python
@pytest.mark.asyncio
async def test_send_draft_via_gmail(
    draft_service: DraftService,
    mock_db: MagicMock,
    sample_draft_data: dict,
) -> None:
    """Test send_draft sends via Gmail integration."""
    with patch("src.services.draft_service.SupabaseClient") as mock_db_class, \
         patch("src.services.draft_service.get_oauth_client") as mock_oauth_getter:

        mock_db_class.get_client.return_value = mock_db

        # First call returns the draft
        mock_db.table.return_value.select.return_value.eq.return_value.eq.return_value.single.return_value.execute.return_value = MagicMock(
            data=sample_draft_data
        )

        # Get integration returns Gmail
        mock_db.table.return_value.select.return_value.eq.return_value.eq.return_value.maybe_single.return_value.execute.return_value = MagicMock(
            data={
                "id": "integration-123",
                "composio_connection_id": "conn-456",
                "integration_type": "gmail",
            }
        )

        # Update returns sent draft
        sent_draft = sample_draft_data.copy()
        sent_draft["status"] = "sent"
        sent_draft["sent_at"] = "2026-02-03T10:00:00Z"
        mock_db.table.return_value.update.return_value.eq.return_value.eq.return_value.execute.return_value = MagicMock(
            data=[sent_draft]
        )

        # Mock OAuth client
        mock_oauth = AsyncMock()
        mock_oauth.execute_action = AsyncMock(return_value={"success": True})
        mock_oauth_getter.return_value = mock_oauth

        result = await draft_service.send_draft("user-456", "draft-123")

        assert result["status"] == "sent"
        assert result["sent_at"] is not None
        mock_oauth.execute_action.assert_called_once()


@pytest.mark.asyncio
async def test_send_draft_fails_without_integration(
    draft_service: DraftService,
    mock_db: MagicMock,
    sample_draft_data: dict,
) -> None:
    """Test send_draft fails when no email integration."""
    with patch("src.services.draft_service.SupabaseClient") as mock_db_class:
        mock_db_class.get_client.return_value = mock_db

        # Return draft
        mock_db.table.return_value.select.return_value.eq.return_value.eq.return_value.single.return_value.execute.return_value = MagicMock(
            data=sample_draft_data
        )

        # No integration found
        mock_db.table.return_value.select.return_value.eq.return_value.eq.return_value.maybe_single.return_value.execute.return_value = MagicMock(
            data=None
        )

        with pytest.raises(Exception) as exc_info:
            await draft_service.send_draft("user-456", "draft-123")

        assert "integration" in str(exc_info.value).lower()
```

**Step 2: Run test to verify it fails**

Run: `cd backend && pytest tests/test_draft_service.py::test_send_draft_via_gmail -v`
Expected: FAIL with `AttributeError: 'DraftService' object has no attribute 'send_draft'`

**Step 3: Add execute_action to OAuth client**

Add to `backend/src/integrations/oauth.py`:

```python
    async def execute_action(
        self,
        connection_id: str,
        action: str,
        params: dict[str, Any],
    ) -> dict[str, Any]:
        """Execute an action via Composio.

        Args:
            connection_id: The connection ID
            action: The action to execute (e.g., 'gmail_send_email')
            params: Parameters for the action

        Returns:
            Action result

        Raises:
            httpx.HTTPError: If the API request fails
        """
        response = await self._http.post(
            f"/connections/{connection_id}/actions/{action}",
            json=params,
        )
        response.raise_for_status()
        return dict(response.json())
```

**Step 4: Add send_draft to DraftService**

Add to `backend/src/services/draft_service.py`:

```python
from src.core.exceptions import EmailDraftError, EmailSendError, NotFoundError
from src.integrations.oauth import get_oauth_client

# ... existing code ...

    async def send_draft(self, user_id: str, draft_id: str) -> dict[str, Any]:
        """Send a draft email via user's email integration.

        Args:
            user_id: The user's ID
            draft_id: The draft ID to send

        Returns:
            Updated draft dictionary with sent status

        Raises:
            NotFoundError: If draft not found
            EmailSendError: If sending fails
        """
        try:
            # Get the draft
            draft = await self.get_draft(user_id, draft_id)
            if draft is None:
                raise NotFoundError("Draft", draft_id)

            if draft["status"] == "sent":
                raise EmailSendError("Draft already sent", draft_id=draft_id)

            # Get user's email integration (Gmail or Outlook)
            integration = await self._get_email_integration(user_id)
            if integration is None:
                raise EmailSendError(
                    "No email integration connected. Please connect Gmail or Outlook.",
                    draft_id=draft_id,
                )

            # Determine action based on integration type
            integration_type = integration["integration_type"]
            if integration_type == "gmail":
                action = "gmail_send_email"
            elif integration_type == "outlook":
                action = "outlook_send_email"
            else:
                raise EmailSendError(
                    f"Unsupported email integration: {integration_type}",
                    draft_id=draft_id,
                )

            # Execute send action via Composio
            oauth_client = get_oauth_client()
            await oauth_client.execute_action(
                connection_id=integration["composio_connection_id"],
                action=action,
                params={
                    "to": draft["recipient_email"],
                    "subject": draft["subject"],
                    "body": draft["body"],
                },
            )

            # Update draft status
            now = datetime.now(UTC)
            updates = {
                "status": "sent",
                "sent_at": now.isoformat(),
            }

            result = await self.update_draft(user_id, draft_id, updates)

            logger.info(
                "Email draft sent",
                extra={
                    "user_id": user_id,
                    "draft_id": draft_id,
                    "integration": integration_type,
                },
            )

            return result

        except (NotFoundError, EmailSendError):
            raise
        except Exception as e:
            # Mark draft as failed
            try:
                await self.update_draft(
                    user_id,
                    draft_id,
                    {"status": "failed", "error_message": str(e)},
                )
            except Exception:
                pass

            logger.exception("Failed to send email draft")
            raise EmailSendError(str(e), draft_id=draft_id) from e

    async def _get_email_integration(self, user_id: str) -> dict[str, Any] | None:
        """Get user's email integration (Gmail or Outlook).

        Args:
            user_id: The user's ID

        Returns:
            Integration dictionary or None
        """
        try:
            client = SupabaseClient.get_client()

            # Try Gmail first
            result = (
                client.table("user_integrations")
                .select("*")
                .eq("user_id", user_id)
                .eq("integration_type", "gmail")
                .maybe_single()
                .execute()
            )

            if result.data:
                return cast(dict[str, Any], result.data)

            # Try Outlook
            result = (
                client.table("user_integrations")
                .select("*")
                .eq("user_id", user_id)
                .eq("integration_type", "outlook")
                .maybe_single()
                .execute()
            )

            if result.data:
                return cast(dict[str, Any], result.data)

            return None

        except Exception:
            logger.warning(f"Failed to get email integration for user {user_id}")
            return None
```

**Step 5: Run tests to verify they pass**

Run: `cd backend && pytest tests/test_draft_service.py -v`
Expected: All 12 tests PASS

**Step 6: Commit**

```bash
git add backend/src/services/draft_service.py backend/src/integrations/oauth.py backend/tests/test_draft_service.py
git commit -m "feat(services): add send_draft capability with Composio integration - US-408"
```

---

## Task 6: Create Drafts API Routes

**Files:**
- Create: `backend/src/api/routes/drafts.py`
- Modify: `backend/src/api/routes/__init__.py`
- Modify: `backend/src/main.py`

**Step 1: Write the failing test**

Create `backend/tests/test_api_drafts.py`:

```python
"""Tests for drafts API routes."""

from datetime import datetime
from unittest.mock import AsyncMock, MagicMock, patch

import pytest
from fastapi.testclient import TestClient

from src.api.deps import get_current_user
from src.main import app


@pytest.fixture
def mock_current_user() -> MagicMock:
    """Create mock current user."""
    user = MagicMock()
    user.id = "test-user-123"
    return user


@pytest.fixture
def test_client(mock_current_user: MagicMock) -> TestClient:
    """Create test client with mocked authentication."""

    async def override_get_current_user() -> MagicMock:
        return mock_current_user

    app.dependency_overrides[get_current_user] = override_get_current_user
    client = TestClient(app)
    yield client
    app.dependency_overrides.clear()


@pytest.fixture
def sample_draft() -> dict:
    """Sample draft response."""
    return {
        "id": "draft-123",
        "user_id": "test-user-123",
        "recipient_email": "test@example.com",
        "recipient_name": "Test User",
        "subject": "Hello",
        "body": "Hi there!",
        "purpose": "intro",
        "tone": "friendly",
        "context": {},
        "lead_memory_id": None,
        "style_match_score": 0.85,
        "status": "draft",
        "sent_at": None,
        "error_message": None,
        "created_at": "2026-02-03T10:00:00Z",
        "updated_at": "2026-02-03T10:00:00Z",
    }


def test_create_draft_success(test_client: TestClient, sample_draft: dict) -> None:
    """Test POST /api/v1/drafts/email creates draft."""
    with patch("src.api.routes.drafts.get_draft_service") as mock_service_getter:
        mock_service = AsyncMock()
        mock_service.create_draft = AsyncMock(return_value=sample_draft)
        mock_service_getter.return_value = mock_service

        response = test_client.post(
            "/api/v1/drafts/email",
            json={
                "recipient_email": "test@example.com",
                "purpose": "intro",
            },
        )

    assert response.status_code == 201
    data = response.json()
    assert data["id"] == "draft-123"
    assert data["subject"] == "Hello"


def test_create_draft_with_all_fields(test_client: TestClient, sample_draft: dict) -> None:
    """Test POST /api/v1/drafts/email with all fields."""
    with patch("src.api.routes.drafts.get_draft_service") as mock_service_getter:
        mock_service = AsyncMock()
        mock_service.create_draft = AsyncMock(return_value=sample_draft)
        mock_service_getter.return_value = mock_service

        response = test_client.post(
            "/api/v1/drafts/email",
            json={
                "recipient_email": "test@example.com",
                "recipient_name": "Test User",
                "subject_hint": "Introduction",
                "purpose": "intro",
                "context": "Met at conference",
                "tone": "formal",
                "lead_memory_id": "lead-123",
            },
        )

    assert response.status_code == 201


def test_list_drafts_returns_drafts(test_client: TestClient, sample_draft: dict) -> None:
    """Test GET /api/v1/drafts returns list of drafts."""
    with patch("src.api.routes.drafts.get_draft_service") as mock_service_getter:
        mock_service = AsyncMock()
        mock_service.list_drafts = AsyncMock(return_value=[sample_draft])
        mock_service_getter.return_value = mock_service

        response = test_client.get("/api/v1/drafts")

    assert response.status_code == 200
    data = response.json()
    assert len(data) == 1
    assert data[0]["id"] == "draft-123"


def test_list_drafts_with_status_filter(test_client: TestClient) -> None:
    """Test GET /api/v1/drafts?status=draft filters by status."""
    with patch("src.api.routes.drafts.get_draft_service") as mock_service_getter:
        mock_service = AsyncMock()
        mock_service.list_drafts = AsyncMock(return_value=[])
        mock_service_getter.return_value = mock_service

        response = test_client.get("/api/v1/drafts?status=draft")

    assert response.status_code == 200
    mock_service.list_drafts.assert_called_once_with("test-user-123", 50, "draft")


def test_get_draft_returns_draft(test_client: TestClient, sample_draft: dict) -> None:
    """Test GET /api/v1/drafts/{id} returns specific draft."""
    with patch("src.api.routes.drafts.get_draft_service") as mock_service_getter:
        mock_service = AsyncMock()
        mock_service.get_draft = AsyncMock(return_value=sample_draft)
        mock_service_getter.return_value = mock_service

        response = test_client.get("/api/v1/drafts/draft-123")

    assert response.status_code == 200
    data = response.json()
    assert data["id"] == "draft-123"


def test_get_draft_returns_404_when_not_found(test_client: TestClient) -> None:
    """Test GET /api/v1/drafts/{id} returns 404 when not found."""
    with patch("src.api.routes.drafts.get_draft_service") as mock_service_getter:
        mock_service = AsyncMock()
        mock_service.get_draft = AsyncMock(return_value=None)
        mock_service_getter.return_value = mock_service

        response = test_client.get("/api/v1/drafts/nonexistent")

    assert response.status_code == 404


def test_update_draft_updates_fields(test_client: TestClient, sample_draft: dict) -> None:
    """Test PUT /api/v1/drafts/{id} updates draft."""
    updated_draft = sample_draft.copy()
    updated_draft["subject"] = "Updated Subject"

    with patch("src.api.routes.drafts.get_draft_service") as mock_service_getter:
        mock_service = AsyncMock()
        mock_service.update_draft = AsyncMock(return_value=updated_draft)
        mock_service_getter.return_value = mock_service

        response = test_client.put(
            "/api/v1/drafts/draft-123",
            json={"subject": "Updated Subject"},
        )

    assert response.status_code == 200
    data = response.json()
    assert data["subject"] == "Updated Subject"


def test_delete_draft_removes_draft(test_client: TestClient) -> None:
    """Test DELETE /api/v1/drafts/{id} deletes draft."""
    with patch("src.api.routes.drafts.get_draft_service") as mock_service_getter:
        mock_service = AsyncMock()
        mock_service.delete_draft = AsyncMock(return_value=True)
        mock_service_getter.return_value = mock_service

        response = test_client.delete("/api/v1/drafts/draft-123")

    assert response.status_code == 200
    assert response.json()["message"] == "Draft deleted successfully"


def test_regenerate_draft_regenerates(test_client: TestClient, sample_draft: dict) -> None:
    """Test POST /api/v1/drafts/{id}/regenerate regenerates draft."""
    regenerated = sample_draft.copy()
    regenerated["body"] = "Regenerated body"

    with patch("src.api.routes.drafts.get_draft_service") as mock_service_getter:
        mock_service = AsyncMock()
        mock_service.regenerate_draft = AsyncMock(return_value=regenerated)
        mock_service_getter.return_value = mock_service

        response = test_client.post("/api/v1/drafts/draft-123/regenerate")

    assert response.status_code == 200
    data = response.json()
    assert data["body"] == "Regenerated body"


def test_regenerate_draft_with_params(test_client: TestClient, sample_draft: dict) -> None:
    """Test POST /api/v1/drafts/{id}/regenerate with parameters."""
    regenerated = sample_draft.copy()
    regenerated["tone"] = "urgent"

    with patch("src.api.routes.drafts.get_draft_service") as mock_service_getter:
        mock_service = AsyncMock()
        mock_service.regenerate_draft = AsyncMock(return_value=regenerated)
        mock_service_getter.return_value = mock_service

        response = test_client.post(
            "/api/v1/drafts/draft-123/regenerate",
            json={"tone": "urgent", "additional_context": "Make it urgent"},
        )

    assert response.status_code == 200
    mock_service.regenerate_draft.assert_called_once()


def test_send_draft_sends_email(test_client: TestClient, sample_draft: dict) -> None:
    """Test POST /api/v1/drafts/{id}/send sends draft."""
    sent_draft = sample_draft.copy()
    sent_draft["status"] = "sent"
    sent_draft["sent_at"] = "2026-02-03T11:00:00Z"

    with patch("src.api.routes.drafts.get_draft_service") as mock_service_getter:
        mock_service = AsyncMock()
        mock_service.send_draft = AsyncMock(return_value=sent_draft)
        mock_service_getter.return_value = mock_service

        response = test_client.post("/api/v1/drafts/draft-123/send")

    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "sent"


def test_drafts_endpoints_require_authentication() -> None:
    """Test all draft endpoints require authentication."""
    client = TestClient(app)

    response = client.post("/api/v1/drafts/email", json={"recipient_email": "test@example.com", "purpose": "intro"})
    assert response.status_code == 401

    response = client.get("/api/v1/drafts")
    assert response.status_code == 401

    response = client.get("/api/v1/drafts/draft-123")
    assert response.status_code == 401

    response = client.put("/api/v1/drafts/draft-123", json={"subject": "New"})
    assert response.status_code == 401

    response = client.delete("/api/v1/drafts/draft-123")
    assert response.status_code == 401

    response = client.post("/api/v1/drafts/draft-123/regenerate")
    assert response.status_code == 401

    response = client.post("/api/v1/drafts/draft-123/send")
    assert response.status_code == 401
```

**Step 2: Run test to verify it fails**

Run: `cd backend && pytest tests/test_api_drafts.py::test_create_draft_success -v`
Expected: FAIL with `404 Not Found` (route doesn't exist)

**Step 3: Create the drafts routes**

Create `backend/src/api/routes/drafts.py`:

```python
"""Drafts API routes for email draft management."""

import logging
from typing import Any

from fastapi import APIRouter, HTTPException, Query, status
from pydantic import BaseModel

from src.api.deps import CurrentUser
from src.core.exceptions import EmailDraftError, EmailSendError, NotFoundError
from src.models.email_draft import (
    EmailDraftCreate,
    EmailDraftListResponse,
    EmailDraftPurpose,
    EmailDraftResponse,
    EmailDraftStatus,
    EmailDraftTone,
    EmailDraftUpdate,
    EmailRegenerateRequest,
    EmailSendResponse,
)
from src.services.draft_service import get_draft_service

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/drafts", tags=["drafts"])


class MessageResponse(BaseModel):
    """Generic message response."""

    message: str


@router.post(
    "/email",
    response_model=EmailDraftResponse,
    status_code=status.HTTP_201_CREATED,
)
async def create_email_draft(
    current_user: CurrentUser,
    request: EmailDraftCreate,
) -> dict[str, Any]:
    """Generate a new email draft.

    Uses ARIA's LLM capabilities and the user's Digital Twin style
    to generate a personalized email draft.

    Args:
        current_user: The authenticated user
        request: Email draft creation parameters

    Returns:
        Created email draft

    Raises:
        HTTPException: If draft generation fails
    """
    try:
        service = get_draft_service()
        draft = await service.create_draft(
            user_id=current_user.id,
            recipient_email=request.recipient_email,
            purpose=request.purpose,
            tone=request.tone,
            recipient_name=request.recipient_name,
            subject_hint=request.subject_hint,
            context=request.context,
            lead_memory_id=request.lead_memory_id,
        )

        logger.info(
            "Email draft created via API",
            extra={
                "user_id": current_user.id,
                "draft_id": draft["id"],
                "purpose": request.purpose.value,
            },
        )

        return draft

    except EmailDraftError as e:
        logger.warning(f"Draft creation failed: {e.message}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=e.message,
        ) from e
    except Exception as e:
        logger.exception("Unexpected error creating draft")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to generate email draft",
        ) from e


@router.get("", response_model=list[EmailDraftListResponse])
async def list_drafts(
    current_user: CurrentUser,
    limit: int = Query(50, ge=1, le=100, description="Maximum drafts to return"),
    status: str | None = Query(None, description="Filter by status (draft, sent, failed)"),
) -> list[dict[str, Any]]:
    """List user's email drafts.

    Args:
        current_user: The authenticated user
        limit: Maximum number of drafts to return
        status: Optional status filter

    Returns:
        List of email drafts
    """
    service = get_draft_service()
    drafts = await service.list_drafts(current_user.id, limit, status)

    logger.info(
        "Drafts listed",
        extra={"user_id": current_user.id, "count": len(drafts)},
    )

    return drafts


@router.get("/{draft_id}", response_model=EmailDraftResponse)
async def get_draft(
    current_user: CurrentUser,
    draft_id: str,
) -> dict[str, Any]:
    """Get a specific email draft.

    Args:
        current_user: The authenticated user
        draft_id: The draft ID

    Returns:
        Email draft details

    Raises:
        HTTPException: If draft not found
    """
    service = get_draft_service()
    draft = await service.get_draft(current_user.id, draft_id)

    if draft is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Draft {draft_id} not found",
        )

    return draft


@router.put("/{draft_id}", response_model=EmailDraftResponse)
async def update_draft(
    current_user: CurrentUser,
    draft_id: str,
    request: EmailDraftUpdate,
) -> dict[str, Any]:
    """Update an email draft.

    Args:
        current_user: The authenticated user
        draft_id: The draft ID
        request: Fields to update

    Returns:
        Updated email draft

    Raises:
        HTTPException: If draft not found or update fails
    """
    try:
        service = get_draft_service()
        updates = request.model_dump(exclude_unset=True)
        draft = await service.update_draft(current_user.id, draft_id, updates)

        logger.info(
            "Draft updated",
            extra={"user_id": current_user.id, "draft_id": draft_id},
        )

        return draft

    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=e.message,
        ) from e
    except EmailDraftError as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=e.message,
        ) from e


@router.delete("/{draft_id}", response_model=MessageResponse)
async def delete_draft(
    current_user: CurrentUser,
    draft_id: str,
) -> dict[str, str]:
    """Delete an email draft.

    Args:
        current_user: The authenticated user
        draft_id: The draft ID

    Returns:
        Success message
    """
    service = get_draft_service()
    success = await service.delete_draft(current_user.id, draft_id)

    if not success:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to delete draft",
        )

    logger.info(
        "Draft deleted",
        extra={"user_id": current_user.id, "draft_id": draft_id},
    )

    return {"message": "Draft deleted successfully"}


@router.post("/{draft_id}/regenerate", response_model=EmailDraftResponse)
async def regenerate_draft(
    current_user: CurrentUser,
    draft_id: str,
    request: EmailRegenerateRequest | None = None,
) -> dict[str, Any]:
    """Regenerate an email draft with different parameters.

    Args:
        current_user: The authenticated user
        draft_id: The draft ID
        request: Optional new parameters

    Returns:
        Regenerated email draft

    Raises:
        HTTPException: If draft not found or regeneration fails
    """
    try:
        service = get_draft_service()

        tone = None
        additional_context = None
        if request:
            tone = request.tone
            additional_context = request.additional_context

        draft = await service.regenerate_draft(
            user_id=current_user.id,
            draft_id=draft_id,
            tone=tone,
            additional_context=additional_context,
        )

        logger.info(
            "Draft regenerated",
            extra={"user_id": current_user.id, "draft_id": draft_id},
        )

        return draft

    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=e.message,
        ) from e
    except EmailDraftError as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=e.message,
        ) from e


@router.post("/{draft_id}/send", response_model=EmailSendResponse)
async def send_draft(
    current_user: CurrentUser,
    draft_id: str,
) -> dict[str, Any]:
    """Send an email draft via user's connected email service.

    Requires Gmail or Outlook integration to be connected.

    Args:
        current_user: The authenticated user
        draft_id: The draft ID to send

    Returns:
        Send result with status

    Raises:
        HTTPException: If draft not found, no integration, or send fails
    """
    try:
        service = get_draft_service()
        result = await service.send_draft(current_user.id, draft_id)

        logger.info(
            "Draft sent",
            extra={"user_id": current_user.id, "draft_id": draft_id},
        )

        return result

    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=e.message,
        ) from e
    except EmailSendError as e:
        raise HTTPException(
            status_code=status.HTTP_502_BAD_GATEWAY,
            detail=e.message,
        ) from e
```

**Step 4: Update routes __init__.py**

Add to `backend/src/api/routes/__init__.py`:

```python
from src.api.routes import drafts
```

**Step 5: Register router in main.py**

Add to `backend/src/main.py` imports:

```python
from src.api.routes import (
    auth,
    battle_cards,
    briefings,
    chat,
    debriefs,
    drafts,  # Add this
    goals,
    integrations,
    memory,
    signals,
)
```

Add router registration after other routers:

```python
app.include_router(drafts.router, prefix="/api/v1")
```

**Step 6: Run tests to verify they pass**

Run: `cd backend && pytest tests/test_api_drafts.py -v`
Expected: All 13 tests PASS

**Step 7: Commit**

```bash
git add backend/src/api/routes/drafts.py backend/src/api/routes/__init__.py backend/src/main.py backend/tests/test_api_drafts.py
git commit -m "feat(api): add drafts routes for email draft management - US-408"
```

---

## Task 7: Run Full Test Suite and Type Checking

**Files:**
- None (verification only)

**Step 1: Run all draft-related tests**

Run: `cd backend && pytest tests/test_email_draft_schema.py tests/test_email_draft_exceptions.py tests/test_draft_service.py tests/test_api_drafts.py -v`
Expected: All tests PASS

**Step 2: Run type checker on all new files**

Run: `cd backend && mypy src/models/email_draft.py src/services/draft_service.py src/api/routes/drafts.py --strict`
Expected: Success: no issues found

**Step 3: Run linter**

Run: `cd backend && ruff check src/models/email_draft.py src/services/draft_service.py src/api/routes/drafts.py`
Expected: No issues

**Step 4: Run full test suite**

Run: `cd backend && pytest tests/ -v --ignore=tests/integration`
Expected: All tests PASS

**Step 5: Commit if any fixes needed**

Only if fixes were required:
```bash
git add -A
git commit -m "fix: resolve test/lint issues for US-408"
```

---

## Task 8: Create Integration Test

**Files:**
- Create: `backend/tests/integration/test_email_draft_integration.py`

**Step 1: Write integration test**

Create `backend/tests/integration/test_email_draft_integration.py`:

```python
"""Integration tests for email draft flow."""

from datetime import UTC, datetime
from unittest.mock import AsyncMock, MagicMock, patch

import pytest
from fastapi.testclient import TestClient

from src.api.deps import get_current_user
from src.main import app


@pytest.fixture
def mock_current_user() -> MagicMock:
    """Create mock current user."""
    user = MagicMock()
    user.id = "integration-test-user"
    return user


@pytest.fixture
def test_client(mock_current_user: MagicMock) -> TestClient:
    """Create test client with mocked authentication."""

    async def override_get_current_user() -> MagicMock:
        return mock_current_user

    app.dependency_overrides[get_current_user] = override_get_current_user
    client = TestClient(app)
    yield client
    app.dependency_overrides.clear()


@pytest.mark.integration
def test_full_draft_lifecycle(test_client: TestClient) -> None:
    """Test complete draft lifecycle: create -> update -> regenerate -> send."""
    draft_id = "lifecycle-draft-123"

    with patch("src.services.draft_service.SupabaseClient") as mock_db_class, \
         patch("src.services.draft_service.LLMClient") as mock_llm_class, \
         patch("src.services.draft_service.DigitalTwin") as mock_twin_class, \
         patch("src.services.draft_service.get_oauth_client") as mock_oauth_getter:

        mock_db = MagicMock()
        mock_db_class.get_client.return_value = mock_db

        # LLM mock
        mock_llm = AsyncMock()
        mock_llm.generate_response = AsyncMock(
            return_value='{"subject": "Test Subject", "body": "Test body content"}'
        )
        mock_llm_class.return_value = mock_llm

        # Digital Twin mock
        mock_twin = AsyncMock()
        mock_twin.get_style_guidelines = AsyncMock(return_value="Write friendly.")
        mock_twin.score_style_match = AsyncMock(return_value=0.85)
        mock_twin_class.return_value = mock_twin

        # Create draft
        created_draft = {
            "id": draft_id,
            "user_id": "integration-test-user",
            "recipient_email": "recipient@example.com",
            "recipient_name": None,
            "subject": "Test Subject",
            "body": "Test body content",
            "purpose": "intro",
            "tone": "friendly",
            "context": {},
            "lead_memory_id": None,
            "style_match_score": 0.85,
            "status": "draft",
            "sent_at": None,
            "error_message": None,
            "created_at": datetime.now(UTC).isoformat(),
            "updated_at": datetime.now(UTC).isoformat(),
        }
        mock_db.table.return_value.insert.return_value.execute.return_value = MagicMock(
            data=[created_draft]
        )

        # 1. Create draft
        response = test_client.post(
            "/api/v1/drafts/email",
            json={
                "recipient_email": "recipient@example.com",
                "purpose": "intro",
            },
        )
        assert response.status_code == 201
        data = response.json()
        assert data["id"] == draft_id
        assert data["status"] == "draft"

        # 2. Update draft
        updated_draft = created_draft.copy()
        updated_draft["subject"] = "Updated Subject"
        mock_db.table.return_value.update.return_value.eq.return_value.eq.return_value.execute.return_value = MagicMock(
            data=[updated_draft]
        )

        response = test_client.put(
            f"/api/v1/drafts/{draft_id}",
            json={"subject": "Updated Subject"},
        )
        assert response.status_code == 200
        assert response.json()["subject"] == "Updated Subject"

        # 3. Regenerate draft
        mock_db.table.return_value.select.return_value.eq.return_value.eq.return_value.single.return_value.execute.return_value = MagicMock(
            data=updated_draft
        )

        regenerated_draft = updated_draft.copy()
        regenerated_draft["body"] = "Regenerated body"
        mock_db.table.return_value.update.return_value.eq.return_value.eq.return_value.execute.return_value = MagicMock(
            data=[regenerated_draft]
        )

        response = test_client.post(
            f"/api/v1/drafts/{draft_id}/regenerate",
            json={"tone": "urgent"},
        )
        assert response.status_code == 200

        # 4. Send draft
        mock_db.table.return_value.select.return_value.eq.return_value.eq.return_value.single.return_value.execute.return_value = MagicMock(
            data=regenerated_draft
        )
        mock_db.table.return_value.select.return_value.eq.return_value.eq.return_value.maybe_single.return_value.execute.return_value = MagicMock(
            data={
                "id": "integration-123",
                "composio_connection_id": "conn-456",
                "integration_type": "gmail",
            }
        )

        sent_draft = regenerated_draft.copy()
        sent_draft["status"] = "sent"
        sent_draft["sent_at"] = datetime.now(UTC).isoformat()
        mock_db.table.return_value.update.return_value.eq.return_value.eq.return_value.execute.return_value = MagicMock(
            data=[sent_draft]
        )

        mock_oauth = AsyncMock()
        mock_oauth.execute_action = AsyncMock(return_value={"success": True})
        mock_oauth_getter.return_value = mock_oauth

        response = test_client.post(f"/api/v1/drafts/{draft_id}/send")
        assert response.status_code == 200
        assert response.json()["status"] == "sent"


@pytest.mark.integration
def test_draft_with_lead_context(test_client: TestClient) -> None:
    """Test draft creation with lead memory context."""
    with patch("src.services.draft_service.SupabaseClient") as mock_db_class, \
         patch("src.services.draft_service.LLMClient") as mock_llm_class, \
         patch("src.services.draft_service.DigitalTwin") as mock_twin_class:

        mock_db = MagicMock()
        mock_db_class.get_client.return_value = mock_db

        # Lead memory query
        mock_db.table.return_value.select.return_value.eq.return_value.eq.return_value.single.return_value.execute.return_value = MagicMock(
            data={
                "id": "lead-456",
                "company_name": "Acme Corp",
                "lifecycle_stage": "opportunity",
                "status": "active",
            }
        )

        # LLM mock
        mock_llm = AsyncMock()
        mock_llm.generate_response = AsyncMock(
            return_value='{"subject": "Following up - Acme Corp", "body": "Hi, I wanted to follow up on our conversation about Acme Corp..."}'
        )
        mock_llm_class.return_value = mock_llm

        # Digital Twin mock
        mock_twin = AsyncMock()
        mock_twin.get_style_guidelines = AsyncMock(return_value="Write professionally.")
        mock_twin.score_style_match = AsyncMock(return_value=0.90)
        mock_twin_class.return_value = mock_twin

        created_draft = {
            "id": "lead-draft-123",
            "user_id": "integration-test-user",
            "recipient_email": "john@acme.com",
            "recipient_name": "John Smith",
            "subject": "Following up - Acme Corp",
            "body": "Hi, I wanted to follow up on our conversation about Acme Corp...",
            "purpose": "follow_up",
            "tone": "friendly",
            "context": {"lead_context": {"company_name": "Acme Corp"}},
            "lead_memory_id": "lead-456",
            "style_match_score": 0.90,
            "status": "draft",
            "sent_at": None,
            "error_message": None,
            "created_at": datetime.now(UTC).isoformat(),
            "updated_at": datetime.now(UTC).isoformat(),
        }
        mock_db.table.return_value.insert.return_value.execute.return_value = MagicMock(
            data=[created_draft]
        )

        response = test_client.post(
            "/api/v1/drafts/email",
            json={
                "recipient_email": "john@acme.com",
                "recipient_name": "John Smith",
                "purpose": "follow_up",
                "lead_memory_id": "lead-456",
            },
        )

        assert response.status_code == 201
        data = response.json()
        assert data["lead_memory_id"] == "lead-456"
        assert "Acme" in data["subject"]
```

**Step 2: Run integration test**

Run: `cd backend && pytest tests/integration/test_email_draft_integration.py -v -m integration`
Expected: All 2 integration tests PASS

**Step 3: Commit**

```bash
git add backend/tests/integration/test_email_draft_integration.py
git commit -m "test: add integration tests for email draft flow - US-408"
```

---

## Task 9: Final Verification and Documentation

**Files:**
- None (verification only)

**Step 1: Run complete test suite**

Run: `cd backend && pytest tests/ -v`
Expected: All tests PASS

**Step 2: Verify all type hints**

Run: `cd backend && mypy src/ --strict`
Expected: Success or only pre-existing issues

**Step 3: Run linter on full codebase**

Run: `cd backend && ruff check src/`
Expected: No new issues

**Step 4: Verify API documentation**

Start server: `cd backend && uvicorn src.main:app --reload`
Open: `http://localhost:8000/docs`
Expected: `/api/v1/drafts/*` endpoints visible with documentation

**Step 5: Final commit**

```bash
git add -A
git commit -m "feat: complete US-408 Email Drafting Backend

- Add email_drafts table with RLS policies
- Add Pydantic models for email draft CRUD
- Add DraftService with LLM generation and Digital Twin style matching
- Add email sending via Composio Gmail/Outlook integration
- Add drafts API routes with full CRUD + regenerate + send
- Add comprehensive unit and integration tests
- All quality gates pass

US-408 Acceptance Criteria:
- [x] POST /api/v1/drafts/email - Generate email draft
- [x] GET /api/v1/drafts - List user's drafts
- [x] GET /api/v1/drafts/{id} - Get specific draft
- [x] PUT /api/v1/drafts/{id} - Update/edit draft
- [x] DELETE /api/v1/drafts/{id} - Delete draft
- [x] POST /api/v1/drafts/{id}/regenerate - Regenerate with different parameters
- [x] POST /api/v1/drafts/{id}/send - Send via OAuth integration (Composio)
- [x] Uses Digital Twin for style matching
- [x] Context-aware (pulls from Lead Memory, conversation history)
- [x] Multiple tone options (formal, friendly, urgent)"
```

---

## Summary

This plan implements US-408: Email Drafting Backend with:

1. **Database**: `email_drafts` table with RLS policies and proper indexes
2. **Models**: Pydantic models for request/response validation
3. **Exceptions**: `EmailDraftError` and `EmailSendError` for proper error handling
4. **Service**: `DraftService` with LLM generation, Digital Twin style matching, and Composio send
5. **API**: Full CRUD routes plus regenerate and send endpoints
6. **Tests**: Unit tests for models, exceptions, service, and API; integration tests for full flow

The implementation follows existing codebase patterns (see `briefings.py`, `integrations.py`) and integrates with:
- Digital Twin for style matching (`src/memory/digital_twin.py`)
- LLM client for generation (`src/core/llm.py`)
- Composio OAuth for email sending (`src/integrations/oauth.py`)
- Lead Memory for context enrichment
