# US-511 & US-512: CRM Bidirectional Sync and Audit Trail Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement bidirectional CRM synchronization between ARIA Lead Memory and external CRMs (Salesforce, HubSpot) with full audit trail for compliance.

**Architecture:** Two new service modules - `CRMSyncService` handles push/pull operations via Composio, state machine for sync status, and conflict resolution. `CRMAuditService` provides immutable logging of all sync operations. Both use the existing `lead_memory_crm_sync` table for state tracking.

**Tech Stack:** Python 3.11+, FastAPI, Supabase (PostgreSQL), Composio OAuth client for CRM API access.

---

## Task 1: Create CRM Sync Domain Models

**Files:**
- Create: `backend/src/services/crm_sync_models.py`
- Test: `backend/tests/test_crm_sync_models.py`

**Step 1: Write the failing test**

```python
"""Tests for CRM sync domain models."""

import pytest
from datetime import datetime, UTC


class TestCRMProviderEnum:
    """Tests for CRMProvider enum."""

    def test_crm_provider_values(self) -> None:
        """Test CRMProvider enum has correct values."""
        from src.services.crm_sync_models import CRMProvider

        assert CRMProvider.SALESFORCE.value == "salesforce"
        assert CRMProvider.HUBSPOT.value == "hubspot"


class TestSyncStatusEnum:
    """Tests for SyncStatus enum."""

    def test_sync_status_values(self) -> None:
        """Test SyncStatus enum has correct state machine values."""
        from src.services.crm_sync_models import SyncStatus

        assert SyncStatus.SYNCED.value == "synced"
        assert SyncStatus.PENDING.value == "pending"
        assert SyncStatus.CONFLICT.value == "conflict"
        assert SyncStatus.ERROR.value == "error"


class TestSyncDirectionEnum:
    """Tests for SyncDirection enum."""

    def test_sync_direction_values(self) -> None:
        """Test SyncDirection enum has correct values."""
        from src.services.crm_sync_models import SyncDirection

        assert SyncDirection.PUSH.value == "push"
        assert SyncDirection.PULL.value == "pull"
        assert SyncDirection.BIDIRECTIONAL.value == "bidirectional"


class TestConflictResolutionEnum:
    """Tests for ConflictResolution enum."""

    def test_conflict_resolution_values(self) -> None:
        """Test ConflictResolution enum has correct values."""
        from src.services.crm_sync_models import ConflictResolution

        assert ConflictResolution.CRM_WINS.value == "crm_wins"
        assert ConflictResolution.ARIA_WINS.value == "aria_wins"
        assert ConflictResolution.MERGE.value == "merge"
        assert ConflictResolution.MANUAL.value == "manual"


class TestCRMSyncStateDataclass:
    """Tests for CRMSyncState dataclass."""

    def test_sync_state_initialization(self) -> None:
        """Test CRMSyncState initializes correctly."""
        from src.services.crm_sync_models import CRMSyncState, SyncStatus

        now = datetime.now(UTC)
        state = CRMSyncState(
            id="sync-123",
            lead_memory_id="lead-456",
            status=SyncStatus.SYNCED,
            last_sync_at=now,
            created_at=now,
            updated_at=now,
        )

        assert state.id == "sync-123"
        assert state.lead_memory_id == "lead-456"
        assert state.status == SyncStatus.SYNCED

    def test_sync_state_to_dict(self) -> None:
        """Test CRMSyncState.to_dict serializes correctly."""
        from src.services.crm_sync_models import CRMSyncState, SyncStatus

        now = datetime.now(UTC)
        state = CRMSyncState(
            id="sync-123",
            lead_memory_id="lead-456",
            status=SyncStatus.PENDING,
            last_sync_at=now,
            pending_changes=[{"field": "stage", "value": "opportunity"}],
            created_at=now,
            updated_at=now,
        )

        data = state.to_dict()

        assert data["id"] == "sync-123"
        assert data["status"] == "pending"
        assert len(data["pending_changes"]) == 1


class TestSyncConflictDataclass:
    """Tests for SyncConflict dataclass."""

    def test_conflict_initialization(self) -> None:
        """Test SyncConflict initializes correctly."""
        from src.services.crm_sync_models import SyncConflict, ConflictResolution

        now = datetime.now(UTC)
        conflict = SyncConflict(
            field="lifecycle_stage",
            aria_value="opportunity",
            crm_value="prospect",
            resolution=ConflictResolution.CRM_WINS,
            resolved_value="prospect",
            detected_at=now,
        )

        assert conflict.field == "lifecycle_stage"
        assert conflict.resolution == ConflictResolution.CRM_WINS


class TestCRMRecordDataclass:
    """Tests for CRMRecord dataclass."""

    def test_crm_record_initialization(self) -> None:
        """Test CRMRecord initializes correctly."""
        from src.services.crm_sync_models import CRMRecord, CRMProvider

        record = CRMRecord(
            crm_id="sf-opp-123",
            provider=CRMProvider.SALESFORCE,
            name="Acme Corp",
            stage="Proposal",
            amount=250000.0,
            close_date="2026-06-30",
            notes=["[ARIA] Previous meeting went well"],
        )

        assert record.crm_id == "sf-opp-123"
        assert record.provider == CRMProvider.SALESFORCE
        assert "[ARIA]" in record.notes[0]
```

**Step 2: Run test to verify it fails**

Run: `cd /Users/dhruv/aria/backend && python -m pytest tests/test_crm_sync_models.py -v`
Expected: FAIL with "ModuleNotFoundError: No module named 'src.services.crm_sync_models'"

**Step 3: Write minimal implementation**

```python
"""Domain models for CRM synchronization."""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any


class CRMProvider(str, Enum):
    """Supported CRM providers."""

    SALESFORCE = "salesforce"
    HUBSPOT = "hubspot"


class SyncStatus(str, Enum):
    """Sync state machine states.

    State transitions:
    - synced -> pending (on local change)
    - pending -> synced (on successful sync)
    - pending -> conflict (on conflicting remote change)
    - pending -> error (on sync failure)
    - conflict -> synced (on resolution)
    - error -> pending (on retry)
    """

    SYNCED = "synced"
    PENDING = "pending"
    CONFLICT = "conflict"
    ERROR = "error"


class SyncDirection(str, Enum):
    """Direction of sync operation."""

    PUSH = "push"  # ARIA -> CRM
    PULL = "pull"  # CRM -> ARIA
    BIDIRECTIONAL = "bidirectional"


class ConflictResolution(str, Enum):
    """How to resolve sync conflicts."""

    CRM_WINS = "crm_wins"  # CRM value takes precedence
    ARIA_WINS = "aria_wins"  # ARIA value takes precedence
    MERGE = "merge"  # Merge both values (for notes)
    MANUAL = "manual"  # Requires user intervention


@dataclass
class SyncConflict:
    """A sync conflict between ARIA and CRM."""

    field: str
    aria_value: Any
    crm_value: Any
    resolution: ConflictResolution
    resolved_value: Any
    detected_at: datetime
    resolved_at: datetime | None = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize conflict to dictionary."""
        return {
            "field": self.field,
            "aria_value": self.aria_value,
            "crm_value": self.crm_value,
            "resolution": self.resolution.value,
            "resolved_value": self.resolved_value,
            "detected_at": self.detected_at.isoformat(),
            "resolved_at": self.resolved_at.isoformat() if self.resolved_at else None,
        }


@dataclass
class CRMSyncState:
    """Sync state for a lead memory record."""

    id: str
    lead_memory_id: str
    status: SyncStatus
    last_sync_at: datetime | None
    created_at: datetime
    updated_at: datetime
    sync_direction: SyncDirection | None = None
    last_push_at: datetime | None = None
    last_pull_at: datetime | None = None
    pending_changes: list[dict[str, Any]] = field(default_factory=list)
    conflict_log: list[dict[str, Any]] = field(default_factory=list)
    error_message: str | None = None
    retry_count: int = 0

    def to_dict(self) -> dict[str, Any]:
        """Serialize sync state to dictionary."""
        return {
            "id": self.id,
            "lead_memory_id": self.lead_memory_id,
            "status": self.status.value,
            "sync_direction": self.sync_direction.value if self.sync_direction else None,
            "last_sync_at": self.last_sync_at.isoformat() if self.last_sync_at else None,
            "last_push_at": self.last_push_at.isoformat() if self.last_push_at else None,
            "last_pull_at": self.last_pull_at.isoformat() if self.last_pull_at else None,
            "pending_changes": self.pending_changes,
            "conflict_log": self.conflict_log,
            "error_message": self.error_message,
            "retry_count": self.retry_count,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat(),
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "CRMSyncState":
        """Create CRMSyncState from dictionary."""
        return cls(
            id=data["id"],
            lead_memory_id=data["lead_memory_id"],
            status=SyncStatus(data["status"]),
            sync_direction=SyncDirection(data["sync_direction"])
            if data.get("sync_direction")
            else None,
            last_sync_at=datetime.fromisoformat(data["last_sync_at"])
            if data.get("last_sync_at")
            else None,
            last_push_at=datetime.fromisoformat(data["last_push_at"])
            if data.get("last_push_at")
            else None,
            last_pull_at=datetime.fromisoformat(data["last_pull_at"])
            if data.get("last_pull_at")
            else None,
            pending_changes=data.get("pending_changes") or [],
            conflict_log=data.get("conflict_log") or [],
            error_message=data.get("error_message"),
            retry_count=data.get("retry_count", 0),
            created_at=datetime.fromisoformat(data["created_at"])
            if isinstance(data["created_at"], str)
            else data["created_at"],
            updated_at=datetime.fromisoformat(data["updated_at"])
            if isinstance(data["updated_at"], str)
            else data["updated_at"],
        )


@dataclass
class CRMRecord:
    """A record from a CRM system."""

    crm_id: str
    provider: CRMProvider
    name: str
    stage: str | None = None
    amount: float | None = None
    close_date: str | None = None
    notes: list[str] = field(default_factory=list)
    activities: list[dict[str, Any]] = field(default_factory=list)
    contacts: list[dict[str, Any]] = field(default_factory=list)
    metadata: dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> dict[str, Any]:
        """Serialize CRM record to dictionary."""
        return {
            "crm_id": self.crm_id,
            "provider": self.provider.value,
            "name": self.name,
            "stage": self.stage,
            "amount": self.amount,
            "close_date": self.close_date,
            "notes": self.notes,
            "activities": self.activities,
            "contacts": self.contacts,
            "metadata": self.metadata,
        }
```

**Step 4: Run test to verify it passes**

Run: `cd /Users/dhruv/aria/backend && python -m pytest tests/test_crm_sync_models.py -v`
Expected: PASS

**Step 5: Commit**

```bash
git add backend/src/services/crm_sync_models.py backend/tests/test_crm_sync_models.py
git commit -m "feat(crm-sync): add domain models for CRM synchronization

- Add CRMProvider enum (salesforce, hubspot)
- Add SyncStatus state machine (synced, pending, conflict, error)
- Add SyncDirection and ConflictResolution enums
- Add CRMSyncState dataclass with serialization
- Add SyncConflict and CRMRecord dataclasses

US-511"
```

---

## Task 2: Create CRM Sync Exceptions

**Files:**
- Modify: `backend/src/core/exceptions.py` (add new exceptions)
- Test: `backend/tests/test_crm_sync_exceptions.py`

**Step 1: Write the failing test**

```python
"""Tests for CRM sync exceptions."""

import pytest


class TestCRMSyncError:
    """Tests for CRMSyncError exception."""

    def test_crm_sync_error_initialization(self) -> None:
        """Test CRMSyncError initializes correctly."""
        from src.core.exceptions import CRMSyncError

        error = CRMSyncError("Sync failed")
        assert "CRM sync error" in str(error)
        assert error.code == "CRM_SYNC_ERROR"
        assert error.status_code == 500

    def test_crm_sync_error_with_provider(self) -> None:
        """Test CRMSyncError with provider context."""
        from src.core.exceptions import CRMSyncError

        error = CRMSyncError("API rate limit exceeded", provider="salesforce")
        assert error.details["provider"] == "salesforce"


class TestCRMConnectionError:
    """Tests for CRMConnectionError exception."""

    def test_crm_connection_error(self) -> None:
        """Test CRMConnectionError initializes correctly."""
        from src.core.exceptions import CRMConnectionError

        error = CRMConnectionError("salesforce")
        assert "salesforce" in str(error)
        assert error.code == "CRM_CONNECTION_ERROR"
        assert error.status_code == 502


class TestCRMSyncConflictError:
    """Tests for CRMSyncConflictError exception."""

    def test_conflict_error_with_fields(self) -> None:
        """Test CRMSyncConflictError with field details."""
        from src.core.exceptions import CRMSyncConflictError

        error = CRMSyncConflictError(
            lead_id="lead-123",
            conflicting_fields=["stage", "expected_value"],
        )
        assert error.code == "CRM_SYNC_CONFLICT"
        assert error.status_code == 409
        assert "lead-123" in error.details["lead_id"]
        assert "stage" in error.details["conflicting_fields"]


class TestCRMSyncNotFoundError:
    """Tests for CRMSyncNotFoundError exception."""

    def test_sync_not_found_error(self) -> None:
        """Test CRMSyncNotFoundError initializes correctly."""
        from src.core.exceptions import CRMSyncNotFoundError

        error = CRMSyncNotFoundError("lead-123")
        assert "lead-123" in str(error)
        assert error.code == "NOT_FOUND"
        assert error.status_code == 404
```

**Step 2: Run test to verify it fails**

Run: `cd /Users/dhruv/aria/backend && python -m pytest tests/test_crm_sync_exceptions.py -v`
Expected: FAIL with "ImportError: cannot import name 'CRMSyncError'"

**Step 3: Write minimal implementation**

Add to `backend/src/core/exceptions.py`:

```python
class CRMSyncError(ARIAException):
    """CRM synchronization error (500).

    Used for failures during CRM sync operations.
    """

    def __init__(
        self,
        message: str = "Unknown error",
        provider: str | None = None,
    ) -> None:
        """Initialize CRM sync error.

        Args:
            message: Error details.
            provider: Optional CRM provider name.
        """
        details = {}
        if provider:
            details["provider"] = provider
        super().__init__(
            message=f"CRM sync error: {message}",
            code="CRM_SYNC_ERROR",
            status_code=500,
            details=details,
        )


class CRMConnectionError(ARIAException):
    """CRM connection error (502).

    Used when unable to connect to CRM provider.
    """

    def __init__(self, provider: str, message: str | None = None) -> None:
        """Initialize CRM connection error.

        Args:
            provider: The CRM provider name.
            message: Optional error message.
        """
        error_message = message or f"Failed to connect to {provider}"
        super().__init__(
            message=error_message,
            code="CRM_CONNECTION_ERROR",
            status_code=502,
            details={"provider": provider},
        )


class CRMSyncConflictError(ARIAException):
    """CRM sync conflict error (409).

    Raised when there are conflicting changes between ARIA and CRM.
    """

    def __init__(
        self,
        lead_id: str,
        conflicting_fields: list[str],
    ) -> None:
        """Initialize CRM sync conflict error.

        Args:
            lead_id: The lead ID with conflicts.
            conflicting_fields: List of fields with conflicts.
        """
        super().__init__(
            message=f"Sync conflict detected for lead '{lead_id}' on fields: {', '.join(conflicting_fields)}",
            code="CRM_SYNC_CONFLICT",
            status_code=409,
            details={
                "lead_id": lead_id,
                "conflicting_fields": conflicting_fields,
            },
        )


class CRMSyncNotFoundError(NotFoundError):
    """CRM sync state not found error (404)."""

    def __init__(self, lead_id: str) -> None:
        """Initialize CRM sync not found error.

        Args:
            lead_id: The lead ID with no sync state.
        """
        super().__init__(resource="CRM sync state", resource_id=lead_id)
```

**Step 4: Run test to verify it passes**

Run: `cd /Users/dhruv/aria/backend && python -m pytest tests/test_crm_sync_exceptions.py -v`
Expected: PASS

**Step 5: Commit**

```bash
git add backend/src/core/exceptions.py backend/tests/test_crm_sync_exceptions.py
git commit -m "feat(crm-sync): add CRM sync exceptions

- Add CRMSyncError for general sync failures
- Add CRMConnectionError for CRM connection issues
- Add CRMSyncConflictError for field conflicts
- Add CRMSyncNotFoundError for missing sync state

US-511"
```

---

## Task 3: Create CRM Audit Service

**Files:**
- Create: `backend/src/services/crm_audit.py`
- Test: `backend/tests/test_crm_audit.py`

**Step 1: Write the failing test**

```python
"""Tests for CRM audit service."""

from datetime import datetime, timedelta, UTC
from unittest.mock import MagicMock, patch

import pytest


class TestCRMAuditOperationEnum:
    """Tests for CRMAuditOperation enum."""

    def test_audit_operation_values(self) -> None:
        """Test CRMAuditOperation enum has correct values."""
        from src.services.crm_audit import CRMAuditOperation

        assert CRMAuditOperation.PUSH.value == "push"
        assert CRMAuditOperation.PULL.value == "pull"
        assert CRMAuditOperation.CONFLICT_DETECTED.value == "conflict_detected"
        assert CRMAuditOperation.CONFLICT_RESOLVED.value == "conflict_resolved"
        assert CRMAuditOperation.ERROR.value == "error"
        assert CRMAuditOperation.RETRY.value == "retry"


class TestCRMAuditEntryDataclass:
    """Tests for CRMAuditEntry dataclass."""

    def test_audit_entry_initialization(self) -> None:
        """Test CRMAuditEntry initializes correctly."""
        from src.services.crm_audit import CRMAuditEntry, CRMAuditOperation

        now = datetime.now(UTC)
        entry = CRMAuditEntry(
            user_id="user-123",
            lead_memory_id="lead-456",
            operation=CRMAuditOperation.PUSH,
            provider="salesforce",
            success=True,
            details={"fields_synced": ["stage", "notes"]},
            created_at=now,
        )

        assert entry.user_id == "user-123"
        assert entry.operation == CRMAuditOperation.PUSH
        assert entry.success is True

    def test_audit_entry_to_dict(self) -> None:
        """Test CRMAuditEntry.to_dict serializes correctly."""
        from src.services.crm_audit import CRMAuditEntry, CRMAuditOperation

        now = datetime.now(UTC)
        entry = CRMAuditEntry(
            user_id="user-123",
            lead_memory_id="lead-456",
            operation=CRMAuditOperation.CONFLICT_DETECTED,
            provider="hubspot",
            success=False,
            details={"conflicting_field": "stage"},
            created_at=now,
        )

        data = entry.to_dict()

        assert data["operation"] == "conflict_detected"
        assert data["provider"] == "hubspot"
        assert data["success"] is False


class TestCRMAuditServiceLogOperation:
    """Tests for CRMAuditService.log_sync_operation()."""

    @pytest.fixture
    def mock_supabase(self) -> MagicMock:
        """Create a mocked Supabase client."""
        mock_client = MagicMock()
        mock_response = MagicMock()
        mock_response.data = [{"id": "audit-123"}]
        mock_client.table.return_value.insert.return_value.execute.return_value = mock_response
        return mock_client

    @pytest.mark.asyncio
    async def test_log_sync_operation_push(self, mock_supabase: MagicMock) -> None:
        """Test logging a push operation."""
        from src.services.crm_audit import CRMAuditService, CRMAuditOperation

        with patch("src.services.crm_audit.SupabaseClient.get_client", return_value=mock_supabase):
            service = CRMAuditService()
            audit_id = await service.log_sync_operation(
                user_id="user-123",
                lead_memory_id="lead-456",
                operation=CRMAuditOperation.PUSH,
                provider="salesforce",
                success=True,
                details={"notes_pushed": 3},
            )

        assert audit_id == "audit-123"
        mock_supabase.table.assert_called_with("crm_audit_log")

    @pytest.mark.asyncio
    async def test_log_sync_operation_stores_all_fields(self, mock_supabase: MagicMock) -> None:
        """Test that log_sync_operation stores all required fields."""
        from src.services.crm_audit import CRMAuditService, CRMAuditOperation

        with patch("src.services.crm_audit.SupabaseClient.get_client", return_value=mock_supabase):
            service = CRMAuditService()
            await service.log_sync_operation(
                user_id="user-123",
                lead_memory_id="lead-456",
                operation=CRMAuditOperation.PULL,
                provider="hubspot",
                success=True,
                details={"stages_synced": 1},
            )

        insert_call = mock_supabase.table.return_value.insert
        insert_data = insert_call.call_args[0][0]
        assert insert_data["user_id"] == "user-123"
        assert insert_data["lead_memory_id"] == "lead-456"
        assert insert_data["operation"] == "pull"
        assert insert_data["provider"] == "hubspot"


class TestCRMAuditServiceLogConflict:
    """Tests for CRMAuditService.log_conflict()."""

    @pytest.fixture
    def mock_supabase(self) -> MagicMock:
        """Create a mocked Supabase client."""
        mock_client = MagicMock()
        mock_response = MagicMock()
        mock_response.data = [{"id": "audit-789"}]
        mock_client.table.return_value.insert.return_value.execute.return_value = mock_response
        return mock_client

    @pytest.mark.asyncio
    async def test_log_conflict_with_resolution(self, mock_supabase: MagicMock) -> None:
        """Test logging a conflict with resolution details."""
        from src.services.crm_audit import CRMAuditService

        with patch("src.services.crm_audit.SupabaseClient.get_client", return_value=mock_supabase):
            service = CRMAuditService()
            audit_id = await service.log_conflict(
                user_id="user-123",
                lead_memory_id="lead-456",
                provider="salesforce",
                field="lifecycle_stage",
                aria_value="opportunity",
                crm_value="prospect",
                resolution="crm_wins",
                resolved_value="prospect",
            )

        assert audit_id == "audit-789"
        insert_data = mock_supabase.table.return_value.insert.call_args[0][0]
        assert insert_data["operation"] == "conflict_resolved"
        assert insert_data["details"]["field"] == "lifecycle_stage"
        assert insert_data["details"]["resolution"] == "crm_wins"


class TestCRMAuditServiceQuery:
    """Tests for CRMAuditService.query_audit_log()."""

    @pytest.fixture
    def mock_supabase_with_logs(self) -> MagicMock:
        """Create a mocked Supabase client with audit logs."""
        mock_client = MagicMock()
        now = datetime.now(UTC)
        mock_response = MagicMock()
        mock_response.data = [
            {
                "id": "audit-1",
                "user_id": "user-123",
                "lead_memory_id": "lead-456",
                "operation": "push",
                "provider": "salesforce",
                "success": True,
                "details": {},
                "created_at": now.isoformat(),
            },
            {
                "id": "audit-2",
                "user_id": "user-123",
                "lead_memory_id": "lead-456",
                "operation": "pull",
                "provider": "salesforce",
                "success": True,
                "details": {},
                "created_at": (now - timedelta(hours=1)).isoformat(),
            },
        ]

        mock_table = MagicMock()
        mock_client.table.return_value = mock_table
        mock_select = MagicMock()
        mock_table.select.return_value = mock_select
        mock_select.eq.return_value = mock_select
        mock_select.gte.return_value = mock_select
        mock_select.lte.return_value = mock_select
        mock_select.order.return_value = mock_select
        mock_select.limit.return_value = mock_select
        mock_select.offset.return_value = mock_select
        mock_select.execute.return_value = mock_response

        return mock_client

    @pytest.mark.asyncio
    async def test_query_by_lead(self, mock_supabase_with_logs: MagicMock) -> None:
        """Test querying audit log by lead ID."""
        from src.services.crm_audit import CRMAuditService

        with patch("src.services.crm_audit.SupabaseClient.get_client", return_value=mock_supabase_with_logs):
            service = CRMAuditService()
            logs = await service.query_audit_log(lead_memory_id="lead-456")

        assert len(logs) == 2
        assert logs[0]["id"] == "audit-1"

    @pytest.mark.asyncio
    async def test_query_by_date_range(self, mock_supabase_with_logs: MagicMock) -> None:
        """Test querying audit log by date range."""
        from src.services.crm_audit import CRMAuditService

        now = datetime.now(UTC)
        start = now - timedelta(days=7)
        end = now

        with patch("src.services.crm_audit.SupabaseClient.get_client", return_value=mock_supabase_with_logs):
            service = CRMAuditService()
            logs = await service.query_audit_log(
                date_start=start,
                date_end=end,
            )

        # Verify gte and lte were called
        mock_select = mock_supabase_with_logs.table.return_value.select.return_value
        mock_select.gte.assert_called()
        mock_select.lte.assert_called()


class TestCRMAuditServiceExport:
    """Tests for CRMAuditService.export_audit_log()."""

    @pytest.fixture
    def mock_supabase_with_logs(self) -> MagicMock:
        """Create a mocked Supabase client with audit logs."""
        mock_client = MagicMock()
        now = datetime.now(UTC)
        mock_response = MagicMock()
        mock_response.data = [
            {
                "id": "audit-1",
                "user_id": "user-123",
                "lead_memory_id": "lead-456",
                "operation": "push",
                "provider": "salesforce",
                "success": True,
                "details": {"notes": 2},
                "created_at": now.isoformat(),
            },
        ]

        mock_table = MagicMock()
        mock_client.table.return_value = mock_table
        mock_select = MagicMock()
        mock_table.select.return_value = mock_select
        mock_select.eq.return_value = mock_select
        mock_select.gte.return_value = mock_select
        mock_select.lte.return_value = mock_select
        mock_select.order.return_value = mock_select
        mock_select.execute.return_value = mock_response

        return mock_client

    @pytest.mark.asyncio
    async def test_export_to_csv_format(self, mock_supabase_with_logs: MagicMock) -> None:
        """Test exporting audit log in CSV format."""
        from src.services.crm_audit import CRMAuditService

        with patch("src.services.crm_audit.SupabaseClient.get_client", return_value=mock_supabase_with_logs):
            service = CRMAuditService()
            csv_data = await service.export_audit_log(
                user_id="user-123",
                format="csv",
            )

        assert "id,user_id,lead_memory_id" in csv_data
        assert "audit-1" in csv_data
        assert "salesforce" in csv_data

    @pytest.mark.asyncio
    async def test_export_to_json_format(self, mock_supabase_with_logs: MagicMock) -> None:
        """Test exporting audit log in JSON format."""
        import json
        from src.services.crm_audit import CRMAuditService

        with patch("src.services.crm_audit.SupabaseClient.get_client", return_value=mock_supabase_with_logs):
            service = CRMAuditService()
            json_data = await service.export_audit_log(
                user_id="user-123",
                format="json",
            )

        parsed = json.loads(json_data)
        assert len(parsed) == 1
        assert parsed[0]["id"] == "audit-1"
```

**Step 2: Run test to verify it fails**

Run: `cd /Users/dhruv/aria/backend && python -m pytest tests/test_crm_audit.py -v`
Expected: FAIL with "ModuleNotFoundError: No module named 'src.services.crm_audit'"

**Step 3: Write minimal implementation**

```python
"""CRM audit service for tracking sync operations.

Provides immutable logging of all CRM synchronization operations
for compliance and debugging purposes.
"""

import csv
import io
import json
import logging
from dataclasses import dataclass
from datetime import datetime, UTC
from enum import Enum
from typing import Any, cast

from src.db.supabase import SupabaseClient

logger = logging.getLogger(__name__)


class CRMAuditOperation(str, Enum):
    """Types of CRM audit operations."""

    PUSH = "push"
    PULL = "pull"
    CONFLICT_DETECTED = "conflict_detected"
    CONFLICT_RESOLVED = "conflict_resolved"
    ERROR = "error"
    RETRY = "retry"


@dataclass
class CRMAuditEntry:
    """A single CRM audit log entry."""

    user_id: str
    lead_memory_id: str
    operation: CRMAuditOperation
    provider: str
    success: bool
    details: dict[str, Any]
    created_at: datetime
    id: str | None = None
    error_message: str | None = None

    def to_dict(self) -> dict[str, Any]:
        """Convert entry to dictionary for database storage."""
        return {
            "user_id": self.user_id,
            "lead_memory_id": self.lead_memory_id,
            "operation": self.operation.value,
            "provider": self.provider,
            "success": self.success,
            "details": self.details,
            "error_message": self.error_message,
        }


class CRMAuditService:
    """Service for CRM audit logging and querying.

    Provides methods to log sync operations, conflicts,
    and query/export audit logs for compliance.
    """

    def _get_supabase_client(self) -> Any:
        """Get the Supabase client instance."""
        return SupabaseClient.get_client()

    async def log_sync_operation(
        self,
        user_id: str,
        lead_memory_id: str,
        operation: CRMAuditOperation,
        provider: str,
        success: bool,
        details: dict[str, Any] | None = None,
        error_message: str | None = None,
    ) -> str:
        """Log a CRM sync operation.

        Args:
            user_id: The user performing the sync.
            lead_memory_id: The lead memory being synced.
            operation: Type of sync operation.
            provider: CRM provider (salesforce, hubspot).
            success: Whether the operation succeeded.
            details: Additional operation details.
            error_message: Error message if failed.

        Returns:
            The ID of the created audit log entry.
        """
        try:
            client = self._get_supabase_client()

            entry = CRMAuditEntry(
                user_id=user_id,
                lead_memory_id=lead_memory_id,
                operation=operation,
                provider=provider,
                success=success,
                details=details or {},
                error_message=error_message,
                created_at=datetime.now(UTC),
            )

            data = entry.to_dict()
            response = client.table("crm_audit_log").insert(data).execute()

            if response.data and len(response.data) > 0:
                audit_id = str(response.data[0].get("id", ""))
                logger.info(
                    "CRM audit log entry created",
                    extra={
                        "audit_id": audit_id,
                        "operation": operation.value,
                        "provider": provider,
                        "lead_memory_id": lead_memory_id,
                    },
                )
                return audit_id

            raise Exception("No data returned from insert")

        except Exception as e:
            logger.exception("Failed to write CRM audit log")
            raise

    async def log_conflict(
        self,
        user_id: str,
        lead_memory_id: str,
        provider: str,
        field: str,
        aria_value: Any,
        crm_value: Any,
        resolution: str,
        resolved_value: Any,
    ) -> str:
        """Log a sync conflict and its resolution.

        Args:
            user_id: The user who owns the lead.
            lead_memory_id: The lead memory with conflict.
            provider: CRM provider.
            field: The conflicting field name.
            aria_value: ARIA's value for the field.
            crm_value: CRM's value for the field.
            resolution: How the conflict was resolved.
            resolved_value: The final resolved value.

        Returns:
            The ID of the created audit log entry.
        """
        details = {
            "field": field,
            "aria_value": aria_value,
            "crm_value": crm_value,
            "resolution": resolution,
            "resolved_value": resolved_value,
        }

        return await self.log_sync_operation(
            user_id=user_id,
            lead_memory_id=lead_memory_id,
            operation=CRMAuditOperation.CONFLICT_RESOLVED,
            provider=provider,
            success=True,
            details=details,
        )

    async def query_audit_log(
        self,
        user_id: str | None = None,
        lead_memory_id: str | None = None,
        operation: CRMAuditOperation | None = None,
        provider: str | None = None,
        success: bool | None = None,
        date_start: datetime | None = None,
        date_end: datetime | None = None,
        limit: int = 100,
        offset: int = 0,
    ) -> list[dict[str, Any]]:
        """Query audit log entries with filters.

        Args:
            user_id: Filter by user ID.
            lead_memory_id: Filter by lead memory ID.
            operation: Filter by operation type.
            provider: Filter by CRM provider.
            success: Filter by success status.
            date_start: Filter by start date.
            date_end: Filter by end date.
            limit: Maximum entries to return.
            offset: Number of entries to skip.

        Returns:
            List of audit log entries.
        """
        try:
            client = self._get_supabase_client()
            query = client.table("crm_audit_log").select("*")

            if user_id is not None:
                query = query.eq("user_id", user_id)

            if lead_memory_id is not None:
                query = query.eq("lead_memory_id", lead_memory_id)

            if operation is not None:
                query = query.eq("operation", operation.value)

            if provider is not None:
                query = query.eq("provider", provider)

            if success is not None:
                query = query.eq("success", success)

            if date_start is not None:
                query = query.gte("created_at", date_start.isoformat())

            if date_end is not None:
                query = query.lte("created_at", date_end.isoformat())

            response = (
                query.order("created_at", desc=True)
                .limit(limit)
                .offset(offset)
                .execute()
            )

            return cast(list[dict[str, Any]], response.data or [])

        except Exception as e:
            logger.exception("Failed to query CRM audit log")
            raise

    async def export_audit_log(
        self,
        user_id: str,
        format: str = "csv",
        lead_memory_id: str | None = None,
        date_start: datetime | None = None,
        date_end: datetime | None = None,
    ) -> str:
        """Export audit log for compliance.

        Args:
            user_id: The user to export logs for.
            format: Export format ("csv" or "json").
            lead_memory_id: Optional filter by lead.
            date_start: Optional start date filter.
            date_end: Optional end date filter.

        Returns:
            Exported data as string (CSV or JSON).
        """
        try:
            client = self._get_supabase_client()
            query = client.table("crm_audit_log").select("*").eq("user_id", user_id)

            if lead_memory_id is not None:
                query = query.eq("lead_memory_id", lead_memory_id)

            if date_start is not None:
                query = query.gte("created_at", date_start.isoformat())

            if date_end is not None:
                query = query.lte("created_at", date_end.isoformat())

            response = query.order("created_at", desc=True).execute()
            logs = response.data or []

            if format == "json":
                return json.dumps(logs, indent=2, default=str)

            # Default to CSV
            if not logs:
                return ""

            output = io.StringIO()
            fieldnames = [
                "id",
                "user_id",
                "lead_memory_id",
                "operation",
                "provider",
                "success",
                "details",
                "error_message",
                "created_at",
            ]
            writer = csv.DictWriter(output, fieldnames=fieldnames, extrasaction="ignore")
            writer.writeheader()

            for log in logs:
                # Convert details dict to string for CSV
                log_copy = log.copy()
                if isinstance(log_copy.get("details"), dict):
                    log_copy["details"] = json.dumps(log_copy["details"])
                writer.writerow(log_copy)

            return output.getvalue()

        except Exception as e:
            logger.exception("Failed to export CRM audit log")
            raise


# Singleton instance
_crm_audit_service: CRMAuditService | None = None


def get_crm_audit_service() -> CRMAuditService:
    """Get or create CRM audit service singleton.

    Returns:
        The shared CRMAuditService instance.
    """
    global _crm_audit_service
    if _crm_audit_service is None:
        _crm_audit_service = CRMAuditService()
    return _crm_audit_service
```

**Step 4: Run test to verify it passes**

Run: `cd /Users/dhruv/aria/backend && python -m pytest tests/test_crm_audit.py -v`
Expected: PASS

**Step 5: Commit**

```bash
git add backend/src/services/crm_audit.py backend/tests/test_crm_audit.py
git commit -m "feat(crm-audit): add CRM audit service for compliance logging

- Add CRMAuditOperation enum for tracking operations
- Add CRMAuditEntry dataclass for audit records
- Add CRMAuditService with:
  - log_sync_operation() for push/pull tracking
  - log_conflict() for conflict resolution details
  - query_audit_log() with filters (lead, direction, status, date)
  - export_audit_log() in CSV/JSON formats

US-512"
```

---

## Task 4: Create CRM Audit Database Migration

**Files:**
- Create: `supabase/migrations/20260204000001_create_crm_audit_log.sql`
- Test: Manual verification via Supabase

**Step 1: Write the migration**

```sql
-- CRM Audit Log Table
-- Tracks all CRM synchronization operations for compliance
CREATE TABLE crm_audit_log (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id) NOT NULL,
    lead_memory_id UUID REFERENCES lead_memories(id) ON DELETE CASCADE,
    operation TEXT NOT NULL,  -- push, pull, conflict_detected, conflict_resolved, error, retry
    provider TEXT NOT NULL,   -- salesforce, hubspot
    success BOOLEAN NOT NULL DEFAULT true,
    details JSONB DEFAULT '{}',
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE crm_audit_log ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own audit logs" ON crm_audit_log
    FOR SELECT USING (user_id = auth.uid());

CREATE POLICY "Service can manage crm_audit_log" ON crm_audit_log
    FOR ALL USING (auth.role() = 'service_role');

-- Indexes for common queries
CREATE INDEX idx_crm_audit_user ON crm_audit_log(user_id);
CREATE INDEX idx_crm_audit_lead ON crm_audit_log(lead_memory_id);
CREATE INDEX idx_crm_audit_operation ON crm_audit_log(operation);
CREATE INDEX idx_crm_audit_provider ON crm_audit_log(provider);
CREATE INDEX idx_crm_audit_time ON crm_audit_log(created_at DESC);
CREATE INDEX idx_crm_audit_user_lead ON crm_audit_log(user_id, lead_memory_id);

-- Comments for documentation
COMMENT ON TABLE crm_audit_log IS 'Immutable audit trail for all CRM synchronization operations.';
COMMENT ON COLUMN crm_audit_log.operation IS 'push (ARIA→CRM), pull (CRM→ARIA), conflict_detected, conflict_resolved, error, retry.';
COMMENT ON COLUMN crm_audit_log.provider IS 'CRM provider: salesforce or hubspot.';
COMMENT ON COLUMN crm_audit_log.details IS 'Operation-specific details: fields synced, conflict resolution, etc.';
```

**Step 2: Apply migration**

Run: `cd /Users/dhruv/aria && supabase db push`
Expected: Migration applied successfully

**Step 3: Commit**

```bash
git add supabase/migrations/20260204000001_create_crm_audit_log.sql
git commit -m "feat(db): add crm_audit_log table for CRM sync audit trail

- Create crm_audit_log table with RLS
- Add indexes for common query patterns
- Add documentation comments

US-512"
```

---

## Task 5: Create CRM Sync Service Core

**Files:**
- Create: `backend/src/services/crm_sync.py`
- Test: `backend/tests/test_crm_sync.py`

**Step 1: Write the failing test (Part 1 - State Management)**

```python
"""Tests for CRM sync service."""

from datetime import datetime, UTC
from unittest.mock import AsyncMock, MagicMock, patch

import pytest


class TestCRMSyncServiceInit:
    """Tests for CRMSyncService initialization."""

    def test_service_initialization(self) -> None:
        """Test CRMSyncService initializes correctly."""
        from src.services.crm_sync import CRMSyncService

        service = CRMSyncService()
        assert service is not None


class TestCRMSyncServiceGetSyncState:
    """Tests for CRMSyncService.get_sync_state()."""

    @pytest.fixture
    def mock_supabase_with_state(self) -> MagicMock:
        """Create a mocked Supabase client with sync state."""
        mock_client = MagicMock()
        now = datetime.now(UTC)
        mock_response = MagicMock()
        mock_response.data = {
            "id": "sync-123",
            "lead_memory_id": "lead-456",
            "status": "synced",
            "sync_direction": "bidirectional",
            "last_sync_at": now.isoformat(),
            "last_push_at": now.isoformat(),
            "last_pull_at": now.isoformat(),
            "pending_changes": [],
            "conflict_log": [],
            "error_message": None,
            "created_at": now.isoformat(),
            "updated_at": now.isoformat(),
        }
        mock_client.table.return_value.select.return_value.eq.return_value.maybe_single.return_value.execute.return_value = mock_response
        return mock_client

    @pytest.mark.asyncio
    async def test_get_sync_state_returns_state(self, mock_supabase_with_state: MagicMock) -> None:
        """Test get_sync_state returns existing state."""
        from src.services.crm_sync import CRMSyncService
        from src.services.crm_sync_models import SyncStatus

        with patch("src.services.crm_sync.SupabaseClient.get_client", return_value=mock_supabase_with_state):
            service = CRMSyncService()
            state = await service.get_sync_state(lead_memory_id="lead-456")

        assert state is not None
        assert state.lead_memory_id == "lead-456"
        assert state.status == SyncStatus.SYNCED

    @pytest.mark.asyncio
    async def test_get_sync_state_returns_none_if_not_found(self) -> None:
        """Test get_sync_state returns None if no state exists."""
        from src.services.crm_sync import CRMSyncService

        mock_client = MagicMock()
        mock_response = MagicMock()
        mock_response.data = None
        mock_client.table.return_value.select.return_value.eq.return_value.maybe_single.return_value.execute.return_value = mock_response

        with patch("src.services.crm_sync.SupabaseClient.get_client", return_value=mock_client):
            service = CRMSyncService()
            state = await service.get_sync_state(lead_memory_id="nonexistent")

        assert state is None


class TestCRMSyncServiceCreateSyncState:
    """Tests for CRMSyncService.create_sync_state()."""

    @pytest.fixture
    def mock_supabase(self) -> MagicMock:
        """Create a mocked Supabase client."""
        mock_client = MagicMock()
        now = datetime.now(UTC)
        mock_response = MagicMock()
        mock_response.data = [{
            "id": "sync-new",
            "lead_memory_id": "lead-789",
            "status": "synced",
            "created_at": now.isoformat(),
            "updated_at": now.isoformat(),
        }]
        mock_client.table.return_value.insert.return_value.execute.return_value = mock_response
        return mock_client

    @pytest.mark.asyncio
    async def test_create_sync_state(self, mock_supabase: MagicMock) -> None:
        """Test creating new sync state."""
        from src.services.crm_sync import CRMSyncService
        from src.services.crm_sync_models import SyncStatus

        with patch("src.services.crm_sync.SupabaseClient.get_client", return_value=mock_supabase):
            service = CRMSyncService()
            state = await service.create_sync_state(lead_memory_id="lead-789")

        assert state.lead_memory_id == "lead-789"
        assert state.status == SyncStatus.SYNCED


class TestCRMSyncServiceUpdateSyncStatus:
    """Tests for CRMSyncService.update_sync_status()."""

    @pytest.fixture
    def mock_supabase(self) -> MagicMock:
        """Create a mocked Supabase client."""
        mock_client = MagicMock()
        now = datetime.now(UTC)
        mock_response = MagicMock()
        mock_response.data = [{
            "id": "sync-123",
            "lead_memory_id": "lead-456",
            "status": "pending",
            "pending_changes": [{"field": "stage"}],
            "created_at": now.isoformat(),
            "updated_at": now.isoformat(),
        }]
        mock_client.table.return_value.update.return_value.eq.return_value.execute.return_value = mock_response
        return mock_client

    @pytest.mark.asyncio
    async def test_update_sync_status_to_pending(self, mock_supabase: MagicMock) -> None:
        """Test updating sync status to pending with changes."""
        from src.services.crm_sync import CRMSyncService
        from src.services.crm_sync_models import SyncStatus

        with patch("src.services.crm_sync.SupabaseClient.get_client", return_value=mock_supabase):
            service = CRMSyncService()
            await service.update_sync_status(
                lead_memory_id="lead-456",
                status=SyncStatus.PENDING,
                pending_changes=[{"field": "stage", "new_value": "opportunity"}],
            )

        update_call = mock_supabase.table.return_value.update
        update_data = update_call.call_args[0][0]
        assert update_data["status"] == "pending"

    @pytest.mark.asyncio
    async def test_update_sync_status_to_error(self, mock_supabase: MagicMock) -> None:
        """Test updating sync status to error with message."""
        from src.services.crm_sync import CRMSyncService
        from src.services.crm_sync_models import SyncStatus

        mock_response = MagicMock()
        mock_response.data = [{"status": "error"}]
        mock_supabase.table.return_value.update.return_value.eq.return_value.execute.return_value = mock_response

        with patch("src.services.crm_sync.SupabaseClient.get_client", return_value=mock_supabase):
            service = CRMSyncService()
            await service.update_sync_status(
                lead_memory_id="lead-456",
                status=SyncStatus.ERROR,
                error_message="API rate limit exceeded",
            )

        update_data = mock_supabase.table.return_value.update.call_args[0][0]
        assert update_data["status"] == "error"
        assert update_data["error_message"] == "API rate limit exceeded"


class TestCRMSyncServicePushSummary:
    """Tests for CRMSyncService.push_summary_to_crm()."""

    @pytest.fixture
    def mock_composio(self) -> MagicMock:
        """Create a mocked Composio client."""
        mock_client = MagicMock()
        mock_client.execute_action = AsyncMock(return_value={"success": True})
        return mock_client

    @pytest.fixture
    def mock_supabase_with_lead(self) -> MagicMock:
        """Create a mocked Supabase client with lead data."""
        mock_client = MagicMock()
        now = datetime.now(UTC)

        # Mock lead memory lookup
        mock_lead_response = MagicMock()
        mock_lead_response.data = {
            "id": "lead-456",
            "user_id": "user-123",
            "company_name": "Acme Corp",
            "crm_id": "sf-opp-789",
            "crm_provider": "salesforce",
            "lifecycle_stage": "opportunity",
            "metadata": {"trigger": "manual"},
            "first_touch_at": now.isoformat(),
            "last_activity_at": now.isoformat(),
            "created_at": now.isoformat(),
            "updated_at": now.isoformat(),
        }

        # Mock sync state lookup - returns None (no existing state)
        mock_sync_response = MagicMock()
        mock_sync_response.data = None

        # Mock sync state insert
        mock_sync_insert_response = MagicMock()
        mock_sync_insert_response.data = [{
            "id": "sync-new",
            "lead_memory_id": "lead-456",
            "status": "synced",
            "created_at": now.isoformat(),
            "updated_at": now.isoformat(),
        }]

        # Mock sync state update
        mock_sync_update_response = MagicMock()
        mock_sync_update_response.data = [{"status": "synced"}]

        # Mock integration lookup
        mock_integration_response = MagicMock()
        mock_integration_response.data = {
            "id": "int-123",
            "composio_connection_id": "conn-456",
        }

        def table_side_effect(table_name: str) -> MagicMock:
            mock_table = MagicMock()
            if table_name == "lead_memories":
                mock_table.select.return_value.eq.return_value.eq.return_value.single.return_value.execute.return_value = mock_lead_response
            elif table_name == "lead_memory_crm_sync":
                mock_table.select.return_value.eq.return_value.maybe_single.return_value.execute.return_value = mock_sync_response
                mock_table.insert.return_value.execute.return_value = mock_sync_insert_response
                mock_table.update.return_value.eq.return_value.execute.return_value = mock_sync_update_response
            elif table_name == "user_integrations":
                mock_table.select.return_value.eq.return_value.eq.return_value.maybe_single.return_value.execute.return_value = mock_integration_response
            return mock_table

        mock_client.table.side_effect = table_side_effect
        return mock_client

    @pytest.mark.asyncio
    async def test_push_summary_tags_with_aria(
        self,
        mock_composio: MagicMock,
        mock_supabase_with_lead: MagicMock,
    ) -> None:
        """Test push_summary_to_crm tags notes with [ARIA]."""
        from src.services.crm_sync import CRMSyncService

        with patch("src.services.crm_sync.SupabaseClient.get_client", return_value=mock_supabase_with_lead):
            with patch("src.services.crm_sync.get_oauth_client", return_value=mock_composio):
                with patch("src.services.crm_sync.get_crm_audit_service") as mock_audit:
                    mock_audit.return_value.log_sync_operation = AsyncMock(return_value="audit-1")

                    service = CRMSyncService()
                    result = await service.push_summary_to_crm(
                        user_id="user-123",
                        lead_memory_id="lead-456",
                        summary="Meeting went well. Budget confirmed.",
                    )

        # Verify the note was tagged with [ARIA]
        action_call = mock_composio.execute_action
        action_call.assert_called_once()
        call_args = action_call.call_args
        assert "[ARIA]" in str(call_args)

    @pytest.mark.asyncio
    async def test_push_summary_logs_audit(
        self,
        mock_composio: MagicMock,
        mock_supabase_with_lead: MagicMock,
    ) -> None:
        """Test push_summary_to_crm logs to audit trail."""
        from src.services.crm_sync import CRMSyncService

        with patch("src.services.crm_sync.SupabaseClient.get_client", return_value=mock_supabase_with_lead):
            with patch("src.services.crm_sync.get_oauth_client", return_value=mock_composio):
                with patch("src.services.crm_sync.get_crm_audit_service") as mock_audit:
                    mock_audit_service = MagicMock()
                    mock_audit_service.log_sync_operation = AsyncMock(return_value="audit-1")
                    mock_audit.return_value = mock_audit_service

                    service = CRMSyncService()
                    await service.push_summary_to_crm(
                        user_id="user-123",
                        lead_memory_id="lead-456",
                        summary="Test summary",
                    )

        mock_audit_service.log_sync_operation.assert_called_once()


class TestCRMSyncServicePullChanges:
    """Tests for CRMSyncService.pull_stage_changes() and pull_activities()."""

    @pytest.fixture
    def mock_composio_with_deal(self) -> MagicMock:
        """Create a mocked Composio client returning deal data."""
        mock_client = MagicMock()
        mock_client.execute_action = AsyncMock(return_value={
            "success": True,
            "data": {
                "stage": "Proposal",
                "amount": 250000,
                "close_date": "2026-06-30",
            },
        })
        return mock_client

    @pytest.fixture
    def mock_supabase_for_pull(self) -> MagicMock:
        """Create a mocked Supabase client for pull operations."""
        mock_client = MagicMock()
        now = datetime.now(UTC)

        # Mock lead memory
        mock_lead_response = MagicMock()
        mock_lead_response.data = {
            "id": "lead-456",
            "user_id": "user-123",
            "company_name": "Acme Corp",
            "crm_id": "sf-opp-789",
            "crm_provider": "salesforce",
            "lifecycle_stage": "lead",  # Different from CRM
            "status": "active",
            "health_score": 50,
            "metadata": {"trigger": "manual"},
            "first_touch_at": now.isoformat(),
            "last_activity_at": now.isoformat(),
            "created_at": now.isoformat(),
            "updated_at": now.isoformat(),
        }

        # Mock sync state
        mock_sync_response = MagicMock()
        mock_sync_response.data = {
            "id": "sync-123",
            "lead_memory_id": "lead-456",
            "status": "synced",
            "created_at": now.isoformat(),
            "updated_at": now.isoformat(),
        }

        # Mock integration
        mock_integration_response = MagicMock()
        mock_integration_response.data = {
            "id": "int-123",
            "composio_connection_id": "conn-456",
        }

        # Mock update responses
        mock_update_response = MagicMock()
        mock_update_response.data = [{"id": "lead-456"}]

        def table_side_effect(table_name: str) -> MagicMock:
            mock_table = MagicMock()
            if table_name == "lead_memories":
                mock_table.select.return_value.eq.return_value.eq.return_value.single.return_value.execute.return_value = mock_lead_response
                mock_table.update.return_value.eq.return_value.eq.return_value.execute.return_value = mock_update_response
            elif table_name == "lead_memory_crm_sync":
                mock_table.select.return_value.eq.return_value.maybe_single.return_value.execute.return_value = mock_sync_response
                mock_table.update.return_value.eq.return_value.execute.return_value = mock_update_response
            elif table_name == "user_integrations":
                mock_table.select.return_value.eq.return_value.eq.return_value.maybe_single.return_value.execute.return_value = mock_integration_response
            return mock_table

        mock_client.table.side_effect = table_side_effect
        return mock_client

    @pytest.mark.asyncio
    async def test_pull_stage_changes_updates_lead(
        self,
        mock_composio_with_deal: MagicMock,
        mock_supabase_for_pull: MagicMock,
    ) -> None:
        """Test pull_stage_changes updates lead memory from CRM."""
        from src.services.crm_sync import CRMSyncService

        with patch("src.services.crm_sync.SupabaseClient.get_client", return_value=mock_supabase_for_pull):
            with patch("src.services.crm_sync.get_oauth_client", return_value=mock_composio_with_deal):
                with patch("src.services.crm_sync.get_crm_audit_service") as mock_audit:
                    mock_audit.return_value.log_sync_operation = AsyncMock(return_value="audit-1")
                    mock_audit.return_value.log_conflict = AsyncMock(return_value="audit-2")

                    service = CRMSyncService()
                    result = await service.pull_stage_changes(
                        user_id="user-123",
                        lead_memory_id="lead-456",
                    )

        assert result["success"] is True
        # Verify lead was updated with CRM stage

    @pytest.mark.asyncio
    async def test_pull_activities_creates_events(
        self,
        mock_supabase_for_pull: MagicMock,
    ) -> None:
        """Test pull_activities creates lead events from CRM."""
        from src.services.crm_sync import CRMSyncService

        mock_composio = MagicMock()
        mock_composio.execute_action = AsyncMock(return_value={
            "success": True,
            "data": {
                "activities": [
                    {"type": "email", "subject": "Follow up", "date": "2026-02-01"},
                    {"type": "call", "subject": "Discovery call", "date": "2026-02-02"},
                ],
            },
        })

        with patch("src.services.crm_sync.SupabaseClient.get_client", return_value=mock_supabase_for_pull):
            with patch("src.services.crm_sync.get_oauth_client", return_value=mock_composio):
                with patch("src.services.crm_sync.get_crm_audit_service") as mock_audit:
                    mock_audit.return_value.log_sync_operation = AsyncMock(return_value="audit-1")

                    service = CRMSyncService()
                    result = await service.pull_activities(
                        user_id="user-123",
                        lead_memory_id="lead-456",
                    )

        assert result["success"] is True
        assert result["activities_synced"] == 2


class TestCRMSyncServiceConflictResolution:
    """Tests for conflict resolution logic."""

    def test_crm_wins_for_structured_fields(self) -> None:
        """Test CRM wins for stage, expected_value, close_date."""
        from src.services.crm_sync import CRMSyncService
        from src.services.crm_sync_models import ConflictResolution

        service = CRMSyncService()

        # Stage field - CRM should win
        resolution = service._resolve_conflict(
            field="lifecycle_stage",
            aria_value="lead",
            crm_value="opportunity",
        )
        assert resolution == ConflictResolution.CRM_WINS

        # Expected value - CRM should win
        resolution = service._resolve_conflict(
            field="expected_value",
            aria_value=100000,
            crm_value=150000,
        )
        assert resolution == ConflictResolution.CRM_WINS

    def test_merge_for_notes(self) -> None:
        """Test merge resolution for notes field."""
        from src.services.crm_sync import CRMSyncService
        from src.services.crm_sync_models import ConflictResolution

        service = CRMSyncService()

        resolution = service._resolve_conflict(
            field="notes",
            aria_value="[ARIA] Good meeting",
            crm_value="Customer mentioned budget concerns",
        )
        assert resolution == ConflictResolution.MERGE


class TestCRMSyncServiceManualSync:
    """Tests for CRMSyncService.trigger_manual_sync()."""

    @pytest.fixture
    def mock_supabase(self) -> MagicMock:
        """Create a mocked Supabase client."""
        mock_client = MagicMock()
        now = datetime.now(UTC)

        mock_lead_response = MagicMock()
        mock_lead_response.data = {
            "id": "lead-456",
            "user_id": "user-123",
            "company_name": "Acme Corp",
            "crm_id": "sf-opp-789",
            "crm_provider": "salesforce",
            "lifecycle_stage": "opportunity",
            "metadata": {"trigger": "manual"},
            "first_touch_at": now.isoformat(),
            "last_activity_at": now.isoformat(),
            "created_at": now.isoformat(),
            "updated_at": now.isoformat(),
        }

        mock_sync_response = MagicMock()
        mock_sync_response.data = {
            "id": "sync-123",
            "lead_memory_id": "lead-456",
            "status": "pending",
            "pending_changes": [{"field": "notes"}],
            "created_at": now.isoformat(),
            "updated_at": now.isoformat(),
        }

        mock_update_response = MagicMock()
        mock_update_response.data = [{"status": "synced"}]

        def table_side_effect(table_name: str) -> MagicMock:
            mock_table = MagicMock()
            if table_name == "lead_memories":
                mock_table.select.return_value.eq.return_value.eq.return_value.single.return_value.execute.return_value = mock_lead_response
            elif table_name == "lead_memory_crm_sync":
                mock_table.select.return_value.eq.return_value.maybe_single.return_value.execute.return_value = mock_sync_response
                mock_table.update.return_value.eq.return_value.execute.return_value = mock_update_response
            return mock_table

        mock_client.table.side_effect = table_side_effect
        return mock_client

    @pytest.mark.asyncio
    async def test_trigger_manual_sync_processes_pending(self, mock_supabase: MagicMock) -> None:
        """Test manual sync processes pending changes."""
        from src.services.crm_sync import CRMSyncService

        mock_composio = MagicMock()
        mock_composio.execute_action = AsyncMock(return_value={"success": True})

        with patch("src.services.crm_sync.SupabaseClient.get_client", return_value=mock_supabase):
            with patch("src.services.crm_sync.get_oauth_client", return_value=mock_composio):
                with patch("src.services.crm_sync.get_crm_audit_service") as mock_audit:
                    mock_audit.return_value.log_sync_operation = AsyncMock(return_value="audit-1")

                    with patch("src.services.crm_sync.get_integration_service") as mock_int_service:
                        mock_int_service.return_value.get_integration = AsyncMock(return_value={
                            "composio_connection_id": "conn-123"
                        })

                        service = CRMSyncService()
                        result = await service.trigger_manual_sync(
                            user_id="user-123",
                            lead_memory_id="lead-456",
                        )

        assert result["success"] is True


class TestCRMSyncServiceRetryLogic:
    """Tests for retry and rate limiting."""

    @pytest.mark.asyncio
    async def test_retry_on_rate_limit(self) -> None:
        """Test retry logic when rate limited."""
        from src.services.crm_sync import CRMSyncService
        from src.services.crm_sync_models import SyncStatus

        mock_client = MagicMock()
        now = datetime.now(UTC)

        # Initial state shows error
        mock_sync_response = MagicMock()
        mock_sync_response.data = {
            "id": "sync-123",
            "lead_memory_id": "lead-456",
            "status": "error",
            "error_message": "Rate limit exceeded",
            "retry_count": 2,
            "created_at": now.isoformat(),
            "updated_at": now.isoformat(),
        }

        mock_update_response = MagicMock()
        mock_update_response.data = [{"status": "pending", "retry_count": 3}]

        def table_side_effect(table_name: str) -> MagicMock:
            mock_table = MagicMock()
            if table_name == "lead_memory_crm_sync":
                mock_table.select.return_value.eq.return_value.maybe_single.return_value.execute.return_value = mock_sync_response
                mock_table.update.return_value.eq.return_value.execute.return_value = mock_update_response
            return mock_table

        mock_client.table.side_effect = table_side_effect

        with patch("src.services.crm_sync.SupabaseClient.get_client", return_value=mock_client):
            service = CRMSyncService()
            result = await service.schedule_retry(lead_memory_id="lead-456")

        assert result["retry_count"] == 3
        assert result["status"] == "pending"

    def test_max_retries_exceeded(self) -> None:
        """Test that max retries are respected."""
        from src.services.crm_sync import CRMSyncService

        service = CRMSyncService()
        assert service._should_retry(retry_count=5) is False
        assert service._should_retry(retry_count=2) is True
```

**Step 2: Run test to verify it fails**

Run: `cd /Users/dhruv/aria/backend && python -m pytest tests/test_crm_sync.py -v`
Expected: FAIL with "ModuleNotFoundError: No module named 'src.services.crm_sync'"

**Step 3: Write minimal implementation**

```python
"""CRM synchronization service.

Provides bidirectional sync between ARIA Lead Memory and CRM systems
(Salesforce, HubSpot) via Composio.
"""

import logging
import uuid
from datetime import datetime, UTC
from typing import Any

from src.db.supabase import SupabaseClient
from src.integrations.oauth import get_oauth_client
from src.integrations.service import get_integration_service
from src.integrations.domain import IntegrationType
from src.services.crm_audit import CRMAuditOperation, get_crm_audit_service
from src.services.crm_sync_models import (
    ConflictResolution,
    CRMProvider,
    CRMSyncState,
    SyncDirection,
    SyncStatus,
)

logger = logging.getLogger(__name__)

# CRM stage mapping for Salesforce and HubSpot
SALESFORCE_STAGE_MAP = {
    "Prospecting": "lead",
    "Qualification": "lead",
    "Proposal": "opportunity",
    "Negotiation": "opportunity",
    "Closed Won": "account",
    "Closed Lost": "account",
}

HUBSPOT_STAGE_MAP = {
    "appointmentscheduled": "lead",
    "qualifiedtobuy": "lead",
    "presentationscheduled": "opportunity",
    "decisionmakerboughtin": "opportunity",
    "contractsent": "opportunity",
    "closedwon": "account",
    "closedlost": "account",
}

# Fields where CRM wins on conflict
CRM_WINS_FIELDS = {"lifecycle_stage", "expected_value", "expected_close_date", "status"}

# Maximum retry attempts
MAX_RETRIES = 5


class CRMSyncService:
    """Service for bidirectional CRM synchronization.

    Handles push/pull operations, conflict resolution, and state management
    for syncing Lead Memory with Salesforce and HubSpot.
    """

    def _get_supabase_client(self) -> Any:
        """Get the Supabase client instance."""
        return SupabaseClient.get_client()

    async def get_sync_state(self, lead_memory_id: str) -> CRMSyncState | None:
        """Get sync state for a lead.

        Args:
            lead_memory_id: The lead memory ID.

        Returns:
            CRMSyncState if exists, None otherwise.
        """
        try:
            client = self._get_supabase_client()
            response = (
                client.table("lead_memory_crm_sync")
                .select("*")
                .eq("lead_memory_id", lead_memory_id)
                .maybe_single()
                .execute()
            )

            if response.data is None:
                return None

            return CRMSyncState.from_dict(response.data)

        except Exception as e:
            logger.exception("Failed to get sync state")
            raise

    async def create_sync_state(self, lead_memory_id: str) -> CRMSyncState:
        """Create initial sync state for a lead.

        Args:
            lead_memory_id: The lead memory ID.

        Returns:
            The created CRMSyncState.
        """
        try:
            client = self._get_supabase_client()
            now = datetime.now(UTC)

            data = {
                "id": str(uuid.uuid4()),
                "lead_memory_id": lead_memory_id,
                "status": SyncStatus.SYNCED.value,
                "last_sync_at": now.isoformat(),
                "pending_changes": [],
                "conflict_log": [],
            }

            response = client.table("lead_memory_crm_sync").insert(data).execute()

            if response.data and len(response.data) > 0:
                return CRMSyncState.from_dict(response.data[0])

            raise Exception("Failed to create sync state")

        except Exception as e:
            logger.exception("Failed to create sync state")
            raise

    async def update_sync_status(
        self,
        lead_memory_id: str,
        status: SyncStatus,
        pending_changes: list[dict[str, Any]] | None = None,
        error_message: str | None = None,
        direction: SyncDirection | None = None,
    ) -> None:
        """Update sync status for a lead.

        Args:
            lead_memory_id: The lead memory ID.
            status: New sync status.
            pending_changes: Optional pending changes to add.
            error_message: Optional error message.
            direction: Optional sync direction.
        """
        try:
            client = self._get_supabase_client()
            now = datetime.now(UTC)

            data: dict[str, Any] = {
                "status": status.value,
                "updated_at": now.isoformat(),
            }

            if pending_changes is not None:
                data["pending_changes"] = pending_changes

            if error_message is not None:
                data["error_message"] = error_message

            if direction is not None:
                data["sync_direction"] = direction.value
                if direction == SyncDirection.PUSH:
                    data["last_push_at"] = now.isoformat()
                elif direction == SyncDirection.PULL:
                    data["last_pull_at"] = now.isoformat()
                data["last_sync_at"] = now.isoformat()

            response = (
                client.table("lead_memory_crm_sync")
                .update(data)
                .eq("lead_memory_id", lead_memory_id)
                .execute()
            )

            if not response.data:
                logger.warning(
                    "No sync state updated",
                    extra={"lead_memory_id": lead_memory_id},
                )

        except Exception as e:
            logger.exception("Failed to update sync status")
            raise

    async def _get_lead_memory(self, user_id: str, lead_memory_id: str) -> dict[str, Any]:
        """Get lead memory record.

        Args:
            user_id: The user ID.
            lead_memory_id: The lead memory ID.

        Returns:
            Lead memory data.
        """
        client = self._get_supabase_client()
        response = (
            client.table("lead_memories")
            .select("*")
            .eq("id", lead_memory_id)
            .eq("user_id", user_id)
            .single()
            .execute()
        )

        if response.data is None:
            from src.core.exceptions import LeadNotFoundError

            raise LeadNotFoundError(lead_memory_id)

        return response.data

    async def _get_crm_connection(
        self,
        user_id: str,
        provider: str,
    ) -> str:
        """Get Composio connection ID for CRM.

        Args:
            user_id: The user ID.
            provider: CRM provider name.

        Returns:
            Composio connection ID.
        """
        integration_service = get_integration_service()
        integration_type = (
            IntegrationType.SALESFORCE
            if provider == "salesforce"
            else IntegrationType.HUBSPOT
        )

        integration = await integration_service.get_integration(user_id, integration_type)
        if integration is None:
            from src.core.exceptions import CRMConnectionError

            raise CRMConnectionError(provider, "No CRM integration found")

        return integration["composio_connection_id"]

    async def push_summary_to_crm(
        self,
        user_id: str,
        lead_memory_id: str,
        summary: str,
    ) -> dict[str, Any]:
        """Push ARIA summary to CRM as a note.

        Notes are tagged with [ARIA] prefix for identification.

        Args:
            user_id: The user ID.
            lead_memory_id: The lead memory ID.
            summary: The summary text to push.

        Returns:
            Result dict with success status.
        """
        audit_service = get_crm_audit_service()

        try:
            # Get lead and verify CRM connection
            lead = await self._get_lead_memory(user_id, lead_memory_id)
            if not lead.get("crm_id") or not lead.get("crm_provider"):
                return {"success": False, "error": "Lead not linked to CRM"}

            provider = lead["crm_provider"]
            crm_id = lead["crm_id"]

            # Get or create sync state
            sync_state = await self.get_sync_state(lead_memory_id)
            if sync_state is None:
                sync_state = await self.create_sync_state(lead_memory_id)

            # Update status to pending
            await self.update_sync_status(
                lead_memory_id,
                SyncStatus.PENDING,
                direction=SyncDirection.PUSH,
            )

            # Get Composio connection
            connection_id = await self._get_crm_connection(user_id, provider)

            # Tag note with [ARIA]
            tagged_summary = f"[ARIA] {summary}"

            # Execute CRM action via Composio
            oauth_client = get_oauth_client()
            action = (
                "salesforce_create_note" if provider == "salesforce" else "hubspot_create_note"
            )

            result = await oauth_client.execute_action(
                connection_id=connection_id,
                action=action,
                params={
                    "record_id": crm_id,
                    "content": tagged_summary,
                },
            )

            # Update sync state to synced
            await self.update_sync_status(
                lead_memory_id,
                SyncStatus.SYNCED,
                direction=SyncDirection.PUSH,
            )

            # Audit log
            await audit_service.log_sync_operation(
                user_id=user_id,
                lead_memory_id=lead_memory_id,
                operation=CRMAuditOperation.PUSH,
                provider=provider,
                success=True,
                details={"summary_length": len(summary)},
            )

            return {"success": True}

        except Exception as e:
            logger.exception("Failed to push summary to CRM")

            # Update sync state to error
            await self.update_sync_status(
                lead_memory_id,
                SyncStatus.ERROR,
                error_message=str(e),
            )

            # Audit log failure
            await audit_service.log_sync_operation(
                user_id=user_id,
                lead_memory_id=lead_memory_id,
                operation=CRMAuditOperation.ERROR,
                provider=lead.get("crm_provider", "unknown"),
                success=False,
                error_message=str(e),
            )

            return {"success": False, "error": str(e)}

    async def pull_stage_changes(
        self,
        user_id: str,
        lead_memory_id: str,
    ) -> dict[str, Any]:
        """Pull stage changes from CRM to Lead Memory.

        CRM wins for structured fields (stage, expected_value, close_date).

        Args:
            user_id: The user ID.
            lead_memory_id: The lead memory ID.

        Returns:
            Result dict with success status and changes.
        """
        audit_service = get_crm_audit_service()

        try:
            lead = await self._get_lead_memory(user_id, lead_memory_id)
            if not lead.get("crm_id") or not lead.get("crm_provider"):
                return {"success": False, "error": "Lead not linked to CRM"}

            provider = lead["crm_provider"]
            crm_id = lead["crm_id"]

            # Get Composio connection
            connection_id = await self._get_crm_connection(user_id, provider)

            # Fetch CRM record
            oauth_client = get_oauth_client()
            action = (
                "salesforce_get_opportunity"
                if provider == "salesforce"
                else "hubspot_get_deal"
            )

            result = await oauth_client.execute_action(
                connection_id=connection_id,
                action=action,
                params={"record_id": crm_id},
            )

            crm_data = result.get("data", {})

            # Map CRM stage to ARIA stage
            stage_map = SALESFORCE_STAGE_MAP if provider == "salesforce" else HUBSPOT_STAGE_MAP
            crm_stage = crm_data.get("stage", "")
            aria_stage = stage_map.get(crm_stage, lead["lifecycle_stage"])

            # Detect conflicts and resolve
            changes = {}
            if aria_stage != lead["lifecycle_stage"]:
                resolution = self._resolve_conflict(
                    "lifecycle_stage",
                    lead["lifecycle_stage"],
                    aria_stage,
                )
                if resolution == ConflictResolution.CRM_WINS:
                    changes["lifecycle_stage"] = aria_stage

                    # Log conflict resolution
                    await audit_service.log_conflict(
                        user_id=user_id,
                        lead_memory_id=lead_memory_id,
                        provider=provider,
                        field="lifecycle_stage",
                        aria_value=lead["lifecycle_stage"],
                        crm_value=aria_stage,
                        resolution="crm_wins",
                        resolved_value=aria_stage,
                    )

            # Apply changes to lead memory
            if changes:
                client = self._get_supabase_client()
                changes["last_activity_at"] = datetime.now(UTC).isoformat()
                changes["updated_at"] = datetime.now(UTC).isoformat()

                client.table("lead_memories").update(changes).eq(
                    "id", lead_memory_id
                ).eq("user_id", user_id).execute()

            # Update sync state
            await self.update_sync_status(
                lead_memory_id,
                SyncStatus.SYNCED,
                direction=SyncDirection.PULL,
            )

            # Audit log
            await audit_service.log_sync_operation(
                user_id=user_id,
                lead_memory_id=lead_memory_id,
                operation=CRMAuditOperation.PULL,
                provider=provider,
                success=True,
                details={"fields_updated": list(changes.keys())},
            )

            return {"success": True, "changes": changes}

        except Exception as e:
            logger.exception("Failed to pull stage changes")
            return {"success": False, "error": str(e)}

    async def pull_activities(
        self,
        user_id: str,
        lead_memory_id: str,
    ) -> dict[str, Any]:
        """Pull activities from CRM to Lead Memory events.

        Args:
            user_id: The user ID.
            lead_memory_id: The lead memory ID.

        Returns:
            Result dict with success status and activity count.
        """
        audit_service = get_crm_audit_service()

        try:
            lead = await self._get_lead_memory(user_id, lead_memory_id)
            if not lead.get("crm_id") or not lead.get("crm_provider"):
                return {"success": False, "error": "Lead not linked to CRM"}

            provider = lead["crm_provider"]
            crm_id = lead["crm_id"]

            # Get Composio connection
            connection_id = await self._get_crm_connection(user_id, provider)

            # Fetch CRM activities
            oauth_client = get_oauth_client()
            action = (
                "salesforce_get_activities"
                if provider == "salesforce"
                else "hubspot_get_engagements"
            )

            result = await oauth_client.execute_action(
                connection_id=connection_id,
                action=action,
                params={"record_id": crm_id},
            )

            activities = result.get("data", {}).get("activities", [])

            # TODO: Create lead events from activities
            # This would create LeadEvent records for each activity

            # Update sync state
            await self.update_sync_status(
                lead_memory_id,
                SyncStatus.SYNCED,
                direction=SyncDirection.PULL,
            )

            # Audit log
            await audit_service.log_sync_operation(
                user_id=user_id,
                lead_memory_id=lead_memory_id,
                operation=CRMAuditOperation.PULL,
                provider=provider,
                success=True,
                details={"activities_count": len(activities)},
            )

            return {"success": True, "activities_synced": len(activities)}

        except Exception as e:
            logger.exception("Failed to pull activities")
            return {"success": False, "error": str(e)}

    def _resolve_conflict(
        self,
        field: str,
        aria_value: Any,
        crm_value: Any,
    ) -> ConflictResolution:
        """Resolve a sync conflict between ARIA and CRM values.

        Args:
            field: The field name with conflict.
            aria_value: ARIA's value.
            crm_value: CRM's value.

        Returns:
            The resolution strategy.
        """
        # CRM wins for structured fields
        if field in CRM_WINS_FIELDS:
            return ConflictResolution.CRM_WINS

        # Merge for notes
        if field == "notes":
            return ConflictResolution.MERGE

        # Default to CRM wins
        return ConflictResolution.CRM_WINS

    async def trigger_manual_sync(
        self,
        user_id: str,
        lead_memory_id: str,
    ) -> dict[str, Any]:
        """Trigger a manual bidirectional sync.

        Args:
            user_id: The user ID.
            lead_memory_id: The lead memory ID.

        Returns:
            Result dict with sync status.
        """
        try:
            # Pull first (CRM wins for structured fields)
            pull_result = await self.pull_stage_changes(user_id, lead_memory_id)

            # Then push any ARIA-specific data
            # (In a real implementation, we'd gather pending summaries)

            return {
                "success": True,
                "pull_result": pull_result,
            }

        except Exception as e:
            logger.exception("Manual sync failed")
            return {"success": False, "error": str(e)}

    async def schedule_retry(
        self,
        lead_memory_id: str,
    ) -> dict[str, Any]:
        """Schedule a retry for a failed sync.

        Args:
            lead_memory_id: The lead memory ID.

        Returns:
            Result dict with new retry count and status.
        """
        try:
            sync_state = await self.get_sync_state(lead_memory_id)
            if sync_state is None:
                return {"success": False, "error": "No sync state found"}

            retry_count = sync_state.retry_count + 1

            if not self._should_retry(retry_count):
                return {
                    "success": False,
                    "error": "Max retries exceeded",
                    "retry_count": retry_count,
                }

            client = self._get_supabase_client()
            response = (
                client.table("lead_memory_crm_sync")
                .update({
                    "status": SyncStatus.PENDING.value,
                    "retry_count": retry_count,
                    "updated_at": datetime.now(UTC).isoformat(),
                })
                .eq("lead_memory_id", lead_memory_id)
                .execute()
            )

            return {
                "success": True,
                "status": "pending",
                "retry_count": retry_count,
            }

        except Exception as e:
            logger.exception("Failed to schedule retry")
            return {"success": False, "error": str(e)}

    def _should_retry(self, retry_count: int) -> bool:
        """Check if sync should be retried.

        Args:
            retry_count: Current retry count.

        Returns:
            True if retry is allowed.
        """
        return retry_count < MAX_RETRIES


# Singleton instance
_crm_sync_service: CRMSyncService | None = None


def get_crm_sync_service() -> CRMSyncService:
    """Get or create CRM sync service singleton.

    Returns:
        The shared CRMSyncService instance.
    """
    global _crm_sync_service
    if _crm_sync_service is None:
        _crm_sync_service = CRMSyncService()
    return _crm_sync_service
```

**Step 4: Run test to verify it passes**

Run: `cd /Users/dhruv/aria/backend && python -m pytest tests/test_crm_sync.py -v`
Expected: PASS

**Step 5: Commit**

```bash
git add backend/src/services/crm_sync.py backend/tests/test_crm_sync.py
git commit -m "feat(crm-sync): add CRM sync service with bidirectional sync

- Add CRMSyncService class with Composio integration
- Support Salesforce and HubSpot via provider abstraction
- Implement push_summary_to_crm() with [ARIA] tagging
- Implement pull_stage_changes() with CRM-wins conflict resolution
- Implement pull_activities() for event creation
- Add sync state machine (synced/pending/conflict/error)
- Add rate limiting with retry logic (max 5 retries)
- Add manual sync trigger

US-511"
```

---

## Task 6: Update Database Migration for Retry Count

**Files:**
- Create: `supabase/migrations/20260204000002_add_crm_sync_retry_count.sql`

**Step 1: Write the migration**

```sql
-- Add retry_count column to lead_memory_crm_sync
ALTER TABLE lead_memory_crm_sync
ADD COLUMN IF NOT EXISTS retry_count INT DEFAULT 0;

-- Add index for finding failed syncs needing retry
CREATE INDEX IF NOT EXISTS idx_crm_sync_status_retry
ON lead_memory_crm_sync(status, retry_count)
WHERE status IN ('error', 'pending');

COMMENT ON COLUMN lead_memory_crm_sync.retry_count IS 'Number of retry attempts after sync failure. Max 5.';
```

**Step 2: Apply migration**

Run: `cd /Users/dhruv/aria && supabase db push`
Expected: Migration applied successfully

**Step 3: Commit**

```bash
git add supabase/migrations/20260204000002_add_crm_sync_retry_count.sql
git commit -m "feat(db): add retry_count column to crm_sync table

US-511"
```

---

## Task 7: Add Module Exports

**Files:**
- Modify: `backend/src/services/__init__.py`

**Step 1: Write the failing test**

```python
"""Test service module exports."""

def test_crm_services_exported() -> None:
    """Test CRM services are exported from services module."""
    from src.services import (
        CRMSyncService,
        CRMAuditService,
        get_crm_sync_service,
        get_crm_audit_service,
    )

    assert CRMSyncService is not None
    assert CRMAuditService is not None
    assert get_crm_sync_service is not None
    assert get_crm_audit_service is not None
```

**Step 2: Run test to verify it fails**

Run: `cd /Users/dhruv/aria/backend && python -m pytest tests/test_service_exports.py -v`
Expected: FAIL with "ImportError"

**Step 3: Update `backend/src/services/__init__.py`**

Add to the file:

```python
from src.services.crm_audit import (
    CRMAuditService,
    CRMAuditOperation,
    CRMAuditEntry,
    get_crm_audit_service,
)
from src.services.crm_sync import (
    CRMSyncService,
    get_crm_sync_service,
)
from src.services.crm_sync_models import (
    CRMProvider,
    CRMSyncState,
    SyncStatus,
    SyncDirection,
    ConflictResolution,
    SyncConflict,
    CRMRecord,
)

__all__ = [
    # ... existing exports ...
    "CRMAuditService",
    "CRMAuditOperation",
    "CRMAuditEntry",
    "get_crm_audit_service",
    "CRMSyncService",
    "get_crm_sync_service",
    "CRMProvider",
    "CRMSyncState",
    "SyncStatus",
    "SyncDirection",
    "ConflictResolution",
    "SyncConflict",
    "CRMRecord",
]
```

**Step 4: Run test to verify it passes**

Run: `cd /Users/dhruv/aria/backend && python -m pytest tests/test_service_exports.py -v`
Expected: PASS

**Step 5: Commit**

```bash
git add backend/src/services/__init__.py backend/tests/test_service_exports.py
git commit -m "feat(services): export CRM sync and audit services

US-511, US-512"
```

---

## Task 8: Run Full Test Suite and Verify

**Step 1: Run all CRM-related tests**

Run: `cd /Users/dhruv/aria/backend && python -m pytest tests/test_crm*.py -v`
Expected: All tests pass

**Step 2: Run type checking**

Run: `cd /Users/dhruv/aria/backend && mypy src/services/crm_sync.py src/services/crm_audit.py src/services/crm_sync_models.py --strict`
Expected: No errors

**Step 3: Run linting**

Run: `cd /Users/dhruv/aria/backend && ruff check src/services/crm*.py`
Expected: No errors

**Step 4: Format code**

Run: `cd /Users/dhruv/aria/backend && ruff format src/services/crm*.py tests/test_crm*.py`
Expected: Files formatted

**Step 5: Final commit**

```bash
git add -A
git commit -m "chore: lint and format CRM sync modules

US-511, US-512"
```

---

## Summary

This plan implements:

1. **CRM Sync Models** (Task 1): Domain models for sync state, conflicts, CRM records
2. **CRM Exceptions** (Task 2): Custom exceptions for sync errors
3. **CRM Audit Service** (Task 3): Immutable logging with query/export
4. **Audit DB Migration** (Task 4): `crm_audit_log` table with RLS
5. **CRM Sync Service** (Task 5): Core sync logic with Composio integration
6. **Retry Migration** (Task 6): `retry_count` column for error handling
7. **Module Exports** (Task 7): Clean public API
8. **Verification** (Task 8): Tests, type checking, linting

Key design decisions:
- **CRM Wins** for structured fields (stage, expected_value, close_date)
- **Merge** for notes (both values preserved)
- **[ARIA] tagging** for pushed notes
- **State machine** for sync status tracking
- **Max 5 retries** for rate limiting
